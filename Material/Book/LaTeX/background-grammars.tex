כוח ההבעה של ביטויים רגולריים מוגבל כיוון שאלו אינם מאפשרים רקורסיה: כלומר, לא
ניתן להפנות להגדרה של ביטוי רגולרי מסויים מתוך ההגדרה של הביטוי עצמו. כך למשל,
לא ניתן לבטא באמצעות ביטוי רגולרי את הדרישה שהסוגריים בתכנית מאוזנים. לעומת
ביטויים רגולריים ניצבים דקדוקים \E|(grammars)|, כלים להגדרת שפות פורמליות, אשר
תומכים בהגדרות רקורסיביות. אנו מבחינים בין דקדוקים שהם חסרי הקשר (\E|context
free grammars|) ובין דקדוקים שהם תלויי הקשר (\E|context sensitive grammars|).

ביטויים רגולריים משמשים להגדרות של אבני הבנין של השפה: מזהים, מספרים, מחרוזות,
סימני פיסוק, וכו'. אבני בנין אלו נקראות אסימונים (\E|tokens|). חלוקת הטקסט של
שפות תכנות לאסימונים, השמטת הערות, רווחים וכו', נקראת \ע|ניתוח לקסיקלי|.
האסימונים, המשך העיבוד העיבוד של תכנית נתונה נעשה באמצעות \ע|ניתוח דקדוקי|.

בהגדרות של שפות תכנות משתמשים בעיקר בדקדוקים חסרי הקשר, הנכתבים פעמים רבות כלל
בשיטת הסימון הידועה בשם Backus Naur Form או \E|BNF|.

הגדרת דקדוק בשיטת סימון זו מורכבת מארבעה חלקים:
\begin{enumerate}
  ✦~$Σ$, קבוצה לא ריקה ולא אינסופית המהווה את האלפאבית של הסימנים הסופיים
  (\E|terminals symbols|) המופיעים בדקדוק. בניתוח דקדוקי של שפת תכנות סימנים
  סופיים האסימונים שזוהו במהלך הניתוח הלקסיקלי. הדקדוק מתאר שפה פורמלית מעל
  אלפאבית זה הסימנים הסופיים.
  ✦~$Γ$, קבוצה לא ריקה ולא אינסופית של סימנים אשר אינם מופיעים ב-$Σ$
  (כלומר~$Γ∪Σ=∅$), והקרויים \ע|סימנים לא סופיים| (\E|non-terminal symbols|).
  השימוש בסימני עזר אלו דומה במקצת לשימוש בשמות של ביטויים רגולריים כדי להגדיר
  ביטויים מורכבים יותר,
    אלא, שהגדרתם של סימני העזר הללו יכולה להיות רקורסיבית.
  ✦ ציון אחד מהסימנים הלא סופיים~$γ₀∈Γ$ כ\ע|סימן התחלה| \E|start symbol|
  ✦ אוסף של \ע|כללי גזירה| (\E|derivation rules|) בעלי המבנה הבא:
  \begin{equation}
    \label{eq:derivation}
    γ₀→ω.
  \end{equation}
 בכל כלל כזה יש שני חלקים
  \begin{description}
✦[ראש הכלל] (\E|rule head|) הכתוב בצידו השמאלי של המפריד, הוא סימן לא סופי~$γ∈Γ$.
✦[גוף הכלל] (\E|rule body|) הכתוב מצידו הימני של המפריד, של המפריד הוא
  \ע|צורת משפט| (\E|sentential form|) סידרה (היכולה להיות ריקה) של סימנים
  סופיים ולא סופיים, כלומר~$ω∈❨Σ∪Γ❩^*$.
  \end{description}
לעיתים משתמשים בסימון~$::=$ כדי להפריד בין ראש הכלל לגופו.
\end{enumerate}

נשתמש בכתיב BNF כדי לתאר את שפת הסוגריים. שפה זו היא שפה פורמלית מעל האלפבית בן
שתי האותיות~$Σ=❴⌘),⌘(❵$, אשר מכילה את כל המילים אשר בהן מספר שווה של
שני סימני האלפבית, ואשר בכל רישה שלהן אין יותר מופעים של~$⌘($, סימן סגירת
הסוגרים, מאשר מופעים של~$⌘)$, סימן פתיחת הסוגריים. דקדוק BNF עבור שפה זו מכיל
את הרכיבים הבאים:

\begin{enumerate}
    ✦ קבוצת הסימנים הסופיים היא האלאפבית~$Σ=❴⌘), ⌘(❵$.
    ✦ קבוצת הסימנים הלא-סופיים מכילה רק סימן אחד~$Γ=❴S❵$
    ✦ הסימן~$γ₀=S$ הוא סימן ההתחלה.
    ✦ שלושה כללי גזירה:
  \begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    S &→ε ⏎
    S &→⌘(S⌘)⏎
    S &→SS ⏎
  \end{split}
\end{equation}
\end{enumerate}

הרקורסיה הטמונה בכללי הגזירה מתגלה בעובדה שכלל הגזירה השני מחליף את צורת
המשפט~$S$ בצורת המשפט~$⌘(S⌘)$, הכוללת את הסימן~$S$. גם כלל הגזירה השלישי מדגים
רקורסיה, כאשר צורת המשפט~$S$ מוחלפת בצורת המשפט~$SS$.

במקרים רבים הגדרת דקדוק מסתפקת ברשימת כללי הגזירה ואינה מפרטת מהם הסימנים
הסופיים, מהם הסימנים הלא סופיים, ואיזה מביניהם הוא סימן ההתחלה.מקריאת כללי
הגזירה \cref{eq:parenthesis} קל לנחש כי הסימן ההתחלתי הוא~$S$, וכי שני הסימנים
הסופיים הם סימני הסוגריים. קל להבחין בין סימנים סופיים ולא סופיים המופיעים
בצורות המשפט שבכללי הגזירה, משום שסימן סופי לא יופיע לעולם בראש כלל. גם סימן
ההתחלה ברור בדרך כלל מההקשר.

§§ דוגמאות

\דוגמה|שפת הפלינדרומים|
$Σ=❴⌘a, ⌘b, ⌘c❵$,~$N=❴S❵$
\begin{equation}
  \label{grammar:palindroms}
  \begin{split}
    S &→ε ⏎
    S &→⌘aS⌘a ⏎
    S &→⌘bS⌘b ⏎
    S &→⌘cS⌘c
  \end{split}
\end{equation}

\דוגמה|שפת הפונקציות הרציונליות|
\label{example:rationals}
$❴⌘1, ⌘I, ⌘), ⌘(, ⌘/, ⌘*, ⌘+, ⌘-❵$ \cref{eq:Q:alphabet}
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    S &→⌘1 ⏎
    S &→⌘I ⏎
    S &→⌘(-S⌘)⏎
    S &→⌘(S⌘+S⌘)⏎
    S &→⌘(S⌘*S⌘)⏎
  \end{split}
\end{equation}

\דוגמה|הדקדוק של שפת העצים|
\label{example:grammar:re}
$\RE(Σ)$, השפה הפורמלית של הביטויים הרגולריים
מעל אלפאבית~$Σ=❴σ₁,σ₂,…,σₙ❵$
כפי שהוגדרה באמצעות כללי היסק
ב\פנה|definition:re| ניתנת להגדרה גם באמצעות דקדוק
מעל האלפבית
$❴σ₁,σ₂,…,σₙ, ⌘., ⌘), ⌘(❵$
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    R &→σ₁ ⏎
    R &→σ₂ ⏎
    ⋮ ⏎
    R &→σₙ ⏎
    R &→⌘(R⌘.R⌘)
  \end{split}
\end{equation}

\דוגמה|הדקדוק של שפת הביטויים הרגולריים|
\label{example:grammar:re}
$\RE(Σ)$, השפה הפורמלית של הביטויים הרגולריים
מעל אלפאבית~$Σ=❴σ₁,σ₂,…,σₙ❵$
כפי שהוגדרה באמצעות כללי היסק
ב\פנה|definition:re| ניתנת להגדרה גם באמצעות דקדוק
מעל האלפבית
$❴σ₁,σ₂,…,σₙ, ⌘|, ⌘;, ⌘*, ⌘), ⌘(❵$
\begin{equation}
  \label{eq:parenthesis}
  \begin{split}
    R &→σ₁ ⏎
    R &→σ₂ ⏎
    ⋮ ⏎
    R &→σₙ ⏎
    R &→⌘(⌘)⏎
    R &→⌘(R R⌘)⏎
    R &→⌘(R ⌘| R⌘)⏎
    R &→⌘(R ⌘*⌘)
  \end{split}
\end{equation}

§§ דקדוקים תלויי הקשר וצורות משפט

דקדוקים תלויי הקשר הם כלליים יותר מאפשר דקדוקים חסרי הקשר, אבל, השימוש בהם
אינו כה נפוץ בהגדרות שפות תכנות (אך נפוץ יותר בניסיון להגדרות פורמליות של
הדקדוק של שפות טבעיות כמו עברית(. תמצית ההבדל בין שני סוגי הדקדוקים הוא המבנה
של כללי הגזירה: ראש כלל הגזריה בדקדוקים תלויי הקשר אינו בהכרח סימן בודד, אלא
הוא יכול להיות צורת משפט כלשהי, ובלבד שאינה ריקה. כלומר, מבנה כלל גזירה בדקדוק כזה הוא
\begin{equation}
  \label{eq:sensitive}
  ω₁→ω₂ \qquad ω₁,ω₂∈❨Σ∪Γ❩^*
\end{equation}
בכל זאת, מקובל להניח שצורת המשפט שבכללי הגזירה מוגבלת למבנה הבא
\begin{equation}
  \label{eq:sensitive:shown}
  ω₁γω₂→ω₁ωω₂ \qquad ω,ω₁,ω₂∈❨Σ∪Γ❩^*
\end{equation}
אשר לפיו הסימן הלא סופי~$γ$ מוחלף בצורת המשפט~$ω$, אולם החלפה זו יכולה להתבצע
רק אם הסימן~$γ$ נמצא בהקשר מסוים: כאשר צורת המשפט~$ω₁$ מקדימה את~$γ$
וצורת המשפט~$ω₂$ מופיעה אחריו. הנחה זו אינה מגבילה את הכלליות, משום שיש דרך לתרגם 
כל דקדוק חסר הקשר שחוקי הגזירה שלו הם במבנה \cref{eq:sensitive}  לדקדוק חסר הקשר שקול
שלכ חוקי הגזירה שלו הם במבנה \cref{eq:sensitive:shown}.


נזכר בכלל ההיסק \פנה|eq:Q:minus| בו נכתב
\begin{equation*}
  \infer{⌘(⌘-w⌘)∈L₁}{w∈L}⏎
\end{equation*}
אולם כדאי לשים לכך ש-$⌘(⌘-w⌘)$ אינה בעצמה מילה מתוך האלפבית
\פנה|eq:Q:alphabet|, ולכן היא בוודאי גם אינה מילה בשפה~$L₁$.
סדרה כמו~$⌘(⌘-w⌘)$, המערבת אותיות מהאלפבית ואותיות שאינן לקוחות ממנו,
נקראת \ע|צורת משפט|
(sentential forms).
לאות המופיעה בצורת משפט ואשר אינה לקוחה מהאלפבית, קוראים סמל
(symbol).

צורת המשפט~$⌘(⌘-w⌘)$, מציינת את כל המילים מעל האלפבית \פנה|eq:Q:alphabet|
המתקבלות אם הסימבול~$w$ יוחלף במילה כלשהי מתוך אלפאבית זה, כלומר, כל המילים
המתחילות בסימן ⌘(, שמייד אחריו בא הסימן ⌘-, ומסתיימות בסימן ⌘).

התנאי המגולם בכלל ההיסק
\begin{equation*}
  \infer{⌘(⌘-w⌘)∈L₁}{w∈L}⏎
\end{equation*}
אומר שהמילה המתקבלת מצורת המשפט~$⌘(⌘-w⌘)$ שייכת לשפה~$L₁$ אם הסמל~$w$ יוחלף
במילה שגם היא שייכת לשפה~$L₁$.

צורות משפט מופיעות גם בכללי ההיסק \cref{eq:Q:plus}, \cref{eq:Q:times}
ו-\cref{eq:Q:times}. נשים לב לכך שצורות המשפט המופיעות בכללים אלו מכילות שני
סמלים ולא אחד. באופן כללי יותר, נבחר קבוצה אינסופית~$𝕊$ של סמלים, שהם סימנים
שאינם מופיעים באף אלפאבית, ונגדיר

\begin{definition}[צורות משפט מעל אלפאבית]
  \label{definition:sentential}
  צורת משפט מעל אלפאבית~$Σ$ היא מילה מתוך~$❨Σ∪𝕊❩^*$.
\end{definition}

כל צורת משפט~$α$ מעל אלפאבית~$Σ$ מגדירה, באופן טריביאלי, שפה פורמלית מעל~$Σ$.
זוהי השפה הפורמלית של כל המילים המתקבלות מ-$α$ על ידי בחירת מילה מ~$Σ^*$ בעבור
כל אחד מהסמלים המופיע ב-$α$ והחלפת כל מופע של סמל במילה המתאימה.

כך למשל, צורת המשפט~$www$ מתארת את השפה הפורמלית~$L₃$ של כל המילים שאפשר לחלק
אותן לשלוש מילים רצופות, זרות, וזהות. כמה מילים בשפה זו (מעל
האלפבית~$❴⌘a,⌘b,⌘c❵$) הן:
\begin{equation}
  \label{eq:L3}
  L₃=❴ε, ⌘{aaa}, ⌘{bbb}, ⌘{ccc}, ⌘{aaaaaa}, ⌘{ababab}, ⌘{acacac}, ⌘{bababa},…❵.
\end{equation}

שימוש חשוב יותר בצורות משפט הוא בכללי גזירה. אם~$α$ ו~$β$, הן צורות משפט אזי
\begin{equation*}
  α→β
\end{equation*}
הוא כלל גזירה שמשמעו החלפת צורת המשפט~$α$ בצורת המשפט~$β$. הפעלה של כלל גזירה
על צורת משפט~$ϕ$ יכולה להעשות אם ניתן למצוא בתוך~$ϕ$ מופע של צורת המשפט~$α$.
אם מופע כזה אכן נמצא, שכתוב של~$ϕ$ באמצעות כלל הגזירה~$α→β$, נעשה באמצעות
החלפת המופע האמור בצורת המשפט~$β$.

למשל
\begin{equation*}
  ⌘(Q⌘*⌘U⌘)→Q
\end{equation*}
הוא כלל גזירה המחליף את~$α=⌘(Q⌘*⌘U⌘)$, צורת משפט באורך~4, בצורת
משפט~$α₂=Q$ באורך~1. כלל זה יכול להיות
מופעל על צורת המשפט
\begin{equation*}
  ϕ=⌘(⌘-⌘(Q⌘*⌘U⌘)⌘),
\end{equation*}
משום שהיא מכילה בתוכה כמילה חלקית את צורת המשפט~$α=⌘(Q⌘*⌘U⌘)$.

מעט פורמלית יותר נאמר שניתן לחלק את~$ϕ$ לשלוש מילים רצופות,~$ϕ=ϕ₁ϕ₂ϕ₃$, כשהמילה
האמצעית שבהן היא צד שמאל של הכלל, כלומר~$ϕ₂=α$. בעבור הדוגמה שלנו, מתקיים
כי~$ϕ₀=⌘(⌘-$, ו-$ϕ₁=⌘)⌘($.

הפעלת הכלל במקרה זה תחזיר את צורת המשפט
\begin{equation*}
  ⌘)⌘-Q⌘).
\end{equation*}
ובאופן כללי, הפעלת הכלל~$α→β$ על המופע של~$α$ בתוך צורת המשפט~$ϕ$ המוגדר על ידי
הפירוק~$ϕ₁αϕ₃=ϕ$ מחזירה את צורת המשפט~$ϕ₁βϕ₃$.

נדגיש כי החיפוש אחר מופע של~$α$ בתוך~$ϕ$ אינו מסתכל על~$α$ כעל תבנית היכולה
להתאים למילים שונות, אלא כמילה שחייבת להימצא ככתבה וכלשונה. מסיבה זו, כלל
הגזירה
$⌘)Q⌘*⌘U⌘)→Q$ המכיל את הסמל~$Q$ בתוך צורת המשפט המצוייה בצידו השמאלי,
אינו יכול לפעול על המילה
\begin{equation*}
  ⌘)⌘)⌘-⌘)⌘I⌘*⌘U ⌘(⌘(⌘*⌘U⌘(
\end{equation*}
שהיא, צורת משפט שאינה מכילה אף לא סמל אחד, ובוודאי לא את הסמל~$Q$.

יתכן כי הצד השמאלי של כלל גזירה יופיע יותר מאשר פעם אחת בצורת
המשפט אותה הוא משכתב. כך למשל, ניתן להפעיל את כלל הגזירה
\begin{equation}
  \label{eq:parenthesis:rewrite}
  S→⌘) S ⌘)
\end{equation}
בשלושה מקומות שונים על צורת המשפט~$SSS$, ולקבל שלוש צורות משפט שונות.
\ע|גזירה שמאלית| היא גזירה בה כלל הגזירה מופעל במופע הראשון של~$α$ בתוך~$ϕ$.
באופן דומה, ניתן גם להגדיר \ע|גזירה ימנית| כגזירה בה כלל הגזירה מופעל במופע
הראשון של~$α$ בתוך~$ϕ$. גזירה שמאלית של~$SSS$ באמצעות כלל הגזירה~$S→⌘)S⌘)$ תיתן
\begin{equation*}
  ⌘)S⌘)SS
\end{equation*}
ואילו גזירה ימנית תיתן
\begin{equation*}
  SS ⌘) S ⌘).
\end{equation*}

§ דקדוקים
בדוגמא זו בדקדוק ישנם שלושה כללי גזירה, אשר מקריאתם מתגלה כי:
\begin{enumerate}
  ✦
  הסימנים הלא סופיים הם S וְ E
  סימן ההתחלה הוא S
  ✦
  הסימנים הלא סופיים הם a וְ b
\end{enumerate}

השפה המוגדרת על ידי הדקדוק חסר ההקשר הזה היא פשוטה ביותר, והיא מכילה את
כל הסדריות שבראשן יש מספר n (שיכול להיות~0) של a ואחריהם n מופעים של
הסימן b.
ניתן להוכיח (ולא נעשה זאת כאן), כי לא ניתן להגדיר שפה זו באמצעות ביטויים
רגולריים.

ה
נה דוגמא המהווה קטע של הדקדוק של שְׂפַת פסקל:

\begin{derivation}
  \begin{align}
    pascal-program→program identifier program-heading ; block . ⏎
    program-heading→𝜺 ⏎
    program-heading→(identifier-list) ⏎
    identifier-list→identifier ⏎
    identifier-list→identifier-list, identifier ⏎
    block→block1 ⏎
    block→label-declaration ; block1 ⏎
    block1→block2 ⏎
    block1→constant-declaration ; block2 ⏎
    block2→block3 ⏎
    block2→type-declaration ; block3 ⏎
    block3→block4 ⏎
    block3→variable-declaration ; block4 ⏎
    block4→block5 ⏎
    block4→proc-and-func-declaration ; block5 ⏎
    block5→begin statement-list end ⏎
…⏎
    type-declaration→type type-declarator ⏎
    type-declaration→type-declaration ; type-declarator ⏎
    type-declarator→identifier=type ⏎
…⏎
    type→identifier ⏎
    type→record field-list \=end=⏎
    field-list→𝜺 ⏎
  \end{align}
\end{derivation}

קל לזהות בהגדרת דקדוק זו את סימן ההתחלה. לשם הנוחות סימנו את הסימנים
הסופיים כגופן וצבע מיוחדים. מהגדרת הדקדוק הזו אנו למדים למשל:
\begin{itemize}
  ✦ תכנית Pascal מתחילה תמיד במילה program ומסתיימת בסימן ". "
  ✦ לתכנית יש שם שאחריו יכולה להופיע רשימת מזהים העטופה בסוגריים עגולים.
  ✦ בראש התכנית יש ארבעה פרקי הגדרות החייבים להופיע בסדר קבוע: הגדרת תוויות,
  ✦ הגדרת קבועים, הגדרת טיפוסים והגדרת משתנים. כל אחד מארבעת מפרקי ההגדרות הוא
  אופציונלי.
  ✦ בהגדרת פרק הטיפוסים אם מופיעה המילה type אזי אחריה חייבת להופיע הגדרת טיפוס
  אחת לפחות.
  ✦ הגדרות הטיפוסים חייבות להיות מופרדות בסימן ";" כל הגדרת טיפוס בודדת מכילה
  מזהה, סימן שיווין, ואחריו גוף הטיפוס, שיכול להיות מזהה או רשומה.

  והנה דוגמא לתכנית פשוטה (וחסרת טעם) המצייתת לדקדוק לעיל:

\end{itemize}
\begin{PASCAL}
program p;
type
  shalem=integer;
  student=record
end;
begin
end.
\end{PASCAL}

הגדרת הדקדוק של שְׂפַת תכנות באמצעות דקדוק חסר הקשר לא נועדה למען הדיוק
בלבד. ישנם כלים אוטומטיים המאפשרים תרגום של דקדוק חסר הקשר כזה לתכנית
ניתוח, אשר לוקחת טכסט נתון, ובונה בעבורו את אופן גזירתו מהדקדוק. אופן
הגזירה הזה נקרא "עץ גזירה" (ַParse Tree) אשר מהווה הוכחה כי הטכסט אמנם
נגזר מהדקדוק. הפורמליזם של דקדוק BNF חזק יותר מהפורמליזם של ביטויים
רגולריים שכן הוא מתיר הגדרות רקורסיביות. כך למשל, בהגדרת הדקדוק של Pascal
נמצא הגדרות רקורסיביות שבהן הסימן הלא סופי statement-list מוגדר באמצעות
הסימן הלא סופי statement ולהיפך:

\begin{align}
  statement-list→statement ⏎
  statement-list→statement-list ; statement⏎
  statement→𝜺⏎
  statement→variable :=expression⏎
  statement→begin statement-list end⏎
  statement→if expression then statement⏎
  statement→if expression then statement else statement⏎
  statement→case expression of case-list end⏎
  statement→while expression do statement⏎
  statement→repeat statement-list until expression⏎
  statement→for varid :=for-list do statement⏎
  statement→procid⏎
  statement→procid(expression-list)⏎
  statement→goto label⏎
  statement→with record-variable-list do statement⏎
  statement→label : statement⏎
\end{align}

הגדרות רקורסיביות מעין אלו הינן חיוניות בהגדרת שפות תכנות מודרניות, אך הן אינן
ניתנות להיעשות בביטויים רגולריים. דקדוקי EBNF EBNF הוא קיצור של Extended BNF.
פורמליזם זה דומה בעיקרו לפורמליזם של דקדוק BNF, אלא שגופו של כלל הגזירה יכול
להיות ביטוי רגולרי מעל אוסף הסימנים, הסופיים והלא סופיים כאחד. שימוש בביטויים
רגולריים כאלו הוא בבחינת תַּחְבִּירִי סֻכָּר לדקדוקי BNF. ההרחבה עצמה אינה מאפשרת
הגדרת שפות פורמליות נוספות פרט לאלו הניתנות להגדרה בדקדוק BNF, אך ניתן באמצות
הרחבה זו להגדיר שפות פורמליות ביתר תמציתיות.

הנה שכתוב של קטע הדקדוק הראשון של Pascal שהבאנו כאן, תוך שימוש בשיטות הסימון
של EBNF.

\begin{align}
  Pascal-program→program identifier [(identifier {,identifier})] ; block .
  block→[label-declaration;]
  [constant-declaration;]
  [type-declaration;]
  [variable-declaration ;]
  begin statement-list end
…
  type-declaration→type ַtype-declarator {; type-declaration}
  type-declarator→identifier=type
  type→identifier | record field-list end
  field-list→𝜺
\end{align}
\endinput
כדאי לשים לב לכך שהכתיב של ביטויים רגולריים בגוף כלל הגזירה של EBNF הוא מעט
שונה. למעלה, בדוגמא הזו השתמשנו בכתיב על פיו * חזרה אפס או יותר פעמים מסומנת על
ידי עטיפה הביטוי החוזר בסוגריים מסולסלים, המעוצבים טיפוגרפית בדוגמא כך: {} כך
למשל תת הביטוי המופיע בגופו של כלל הגזירה הראשון לעיל
identifier {,identifier}
מציין רשימה של אחד או יותר מזהים המופרדים בפסיקים.
\begin{description}
  ✦ ביטוי אופציונלי עטוף בסוגריים מרובעים, המעוצבים טיפוגרפית בדוגמא כך: [] כך למשל תת הביטוי
  [label-declaration;]
  מציין שה label-declaration שאחריו יש סימן ; הוא אופציונלי.
  עוד נשים לכך שהדוגמא מניחה כללי קדימות של האופרטורים היוצרים את הביטוי הרגולרי, בפרט
  identifier | record field-list end
  מתפרש כך:
  identifier | (record field-list end)
  ולא כך:
  (identifier | record) field-list end
\end{description}

דקדוק ה-EBNF של שְׂפַת תכנות מסוימת עשוי להשתמש בשיטת סימון מעט אחרת ואולי אף כללי
קדימות אחרים. בדרך כלל, יכול הקורא הנבון להסיק את שיטת הסימון מתוך הקריאה,
ואילו הקורא הסכל יאלץ לעיין בנספח, בהקדמה או בתוספת אחרת למסמך הראשי, ואשר בהם
אולי תימצא הגדרה מדוייקת של שיטת הסימון.
\eject
\pagecolor{yellow

§ דקדוקים
אוסף השפות הפורמליות הניתנות להגדרה על ידי ביטויים רגולריים הוא מוגבל.

דקדוק חסר הקשר הוא

\החל{definition}
דקדוק חסר הקשר~$G$ הוא רביעיה~$G=⟨V,Σ,R,S⟩$
כאשר~$V$ היא קבוצה של \ע|משתנים|, הקרויים גם
V is called a nonterminal character or a variable. Each variable represents a
different type of phrase or clause in the sentence. Variables are also
sometimes called syntactic categories. Each variable defines a sub-language
of the language defined by G. Σ is a finite set of terminals, disjoint from
V, which make up the actual content of the sentence. The set of terminals is
the alphabet of the language defined by the grammar G.
R is a finite relation from V to~${\displaystyle (V∪Σ)^*}(V∪Σ)^*,~$ן where the
asterisk represents the Kleene star operation. The members of R are called
the (rewrite) rules or productions of the grammar. (also commonly symbolized
by a P) S is the start variable (or start symbol), used to represent the
whole sentence (or program). It must be an element of V.
\סוף{definition}

\endinput
כוח ההבעה של ביטויים רגולריים הוא מוגבל. כך למשל, לא ניתן להביע באמצעות ביטוי
רגולרי את הדרישה שהסוגריים בתכנית מאוזנים. לפיכך, השימוש בביטויים רגולריים
מוגבל להגדרות פשוטות של אסימונים- אבני הבנין של השפה: משתנים, הערות,
מספרים וכו'.

ב§§ הגדרת שפות להגדרת שפה פורמלית באמצעות עצמן

פורמלית, כל שפת תכנות היא שפה פורמלית. ישנן שפות פורמליות שאינן שפות תכנות.
שפות תכנות אינן מכניזם נוח להגדרת שפה פורמלית. מכניזמים להגדרת שפות פורמליות.
מתברר שגם מכניזמים אלו הם שפה פורמלית.

 בדרך כלל, קל הרבה יותר להגדיר שפה פורמלית, מאשר לכתוב מהדר של השפה בעזרת
 עצמה. הנה דוגמאות.
 \ציינן
     ✦ הגדרת BNF בעזרת עצמו
     ✦ הגדרת EBNF בעזרת עצמו
     ✦ ביטוי רגולרי המגדיר מהו ביטוי רגולרי חוקי
===

קל להגדיר את
 משפחת ה-BNF באמצעות ביטוי רגולרי. קל להשתמש ב-BNF כדי להגדיר מהו ביטוי
 רגוליר. אבל, ניתן להגדיר ביטוי רגולרי באמצעות ביטוי רגולרי? לא! רקורסיה.
 טבלת סיכום, הגדרה הדדית.

 מסיבה זו, השפות BNF וְ-EBNF הן אלגנטיות יותר מביטוים רגולריים.
כלל גזירה מאפשר להחליף צורת משפט אחת באחרת. נגדיר מהי צורת משפט, ובאמצעות הגדרה
זו, מהו כלל גזירה, וכיצד מפעילים אותו. בנוסף לכללים, הדקדוק גם קובע צורת משפט
התחלתית. השפה הפורמלית המוגדרת על ידי דקדוק היא אוסף כל המילים שאפשר להגיע
אליהן מהסימן ההתחלתי תוך שימוש בכללי הגזירה.
הדקדוקיים.

כתיב אחר לדקדוקים אלו הוא הדיאגרמות שתוארו לעיל.
