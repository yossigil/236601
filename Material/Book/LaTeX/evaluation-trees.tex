§§ עצי שיערוך

נסתכל על הביטוי הבא בשפת~\CPL
 \begin{equation}
   \label{eq:infix}
   \texttt{\LR{f(2) ? g(++a,--b,-sin(c)) : 10+h()}}
\end{equation}
 נתאר את השיערוך של הביטוי הזה על ידי הצגתו כעץ השיערוך המתואר ב\פנה|איור:עץ|.

\begin{figure}[H]
  \caption[עץ שיערוך של ביטוי בשפת~\LR{C}]
{עץ השיערוך של הביטוי בשפת~\LR{C}: \LR{\tt f(2) ? g(++a,--b,-sin(c)) : 10+h()}}
  \תגית|איור:עץ|
  \centering
  \input Forests/evaluation-tree.tikz
 \end{figure}

בעץ שבאיור יש שישה עלים:
\אבגד
✦ משמעות העלים המסומנים ב-$2$ וב-$10$ היא המספרים~$2$ ו-$10$, שכן בשפת~\CPL
סדרות התווים \T|2| ו-\T|10| הן \ע|מילולונים| (\E|literals|), כלומר סדרות אלו
מציינות ערך הנקבע באופן יחיד על ידי תוכן הסדרה, ללא תלות בטבלת סמלים כלשהי.

✦ משמעות העלים המסומנים ב-$a$, \E|$b$| וב-$c$ נעשית על ידי חיפוש השמות הללו
בטבלת הסמלים מתאימה, שכן בשפת~\CPL סדרות התווים \T|a|, \T|b| ו-\T|c| הם
\ע|מזהים| (\E|identifiers|) של~\CPL. מזהים אלו מתייחסים, ככל הנראה, למשתנים אשר
הוגדרו קודם על ידי המשתמש בשפה.

✦ העלה המסומן ב-$h()$ גם הוא מזהה אשר משמעותו נעשית באמצעות חיפוש השם~$h$ בטבלת
הסמלים המתאימה, אלא שנדרש שהחיפוש בטבלה יקשור את השם לערך שהוא פונקציה.
אם על פי החיפוש, משמעות השם~$h$ היא משתנה, אזי השיערוך של הביטוי יכשל.
===

שיערוך של צומת פנימי מתחיל באופן דומה. ראשית יש לברר את משמעות הסמל אשר
נמצא בתוך הצומת. הצמתים המסומנים~$f()$,~$g()$, ו-$\sin()$, הם כאלו המציינים הפעלת
\ע|פונקציות| של שפת \E|C|. לעומת זאת הצמתים המסומנים בסמלים \T|+|, \T|-|,
\T|++|, \T|--| ו-\T|?:| מציינים הפעלת \ע|אופרטורים| של שפת~\E|\CPL|.

בשפת~\E|C| שבה אנו דנים כל האופרטורים הם קבועים בשפה, ואין למתכנת אפשרות
לשנותם. לכן, אין צורך למהדר או לאינטרפרטר צורך או טעם לחפש את משמעותם של חמשת
האופרטורים \T|+|, \T|-|, \T|++|, \T|--| ו-\T|?:| בטבלת סמלים: הפונקציות אותן
מציינים חמשת אלו הם תמיד אותן פונקציות.

לעומת זאת, ברור ש-\T|f| ו-\T|g| הם שמות של פונקציות שהוגדרו על ידי מתכנת. הם
אינם חלק משפת~\E|C|. נזכיר שהשם \T|sin| אינו שונה משני אלו, ואף הוא
שם של פונקציה שהוגדרה על ידי מתכנת, שכן הפונקציה~$\sin$ אינה בנויה
בשפת~\E|\CPL|: פונקציה זו מוגדרת בסיפריה \ע|אופציונלית| של פונקציות מתימטיות
הנספחת לשפת~\E|C|. סיפריה זו אינה חלק מהשפה. היא נכתבה על יד מתכנת או מתכנתים
בשפת~\E|C|, היא מצטרפת לפונקציות אותם כתב המשתמש ה"רגיל" בשפה, ולדידו של המהדר
של שפת~\E|C| היא אינה שונה מפונקציות אחרות: גם את משמעותו של המזהה \T|sin| יש
למצוא בטבלת סמלים.

לאחר בירור משמעותו של צומת פנימי, בין אם זו קבועה בשפה, כיוון שהצומת מייצג
אופרטור, ובין אם זו מצויה בטבלת הסמלים, יש לחשב את ערכי תתי העצים של הצומת,
ולהעביר את תוצאות החישוב של תתי העצים כארגומנטים לפונקציה.

בשפה העוברת הידור, משמעות הסימבולים השונים מחושבת בזמן ההידור, כמובן, ככל שהדבר
ניתן: הקישור בין שמות הפונקציות למימוש שלהן נעשה בזמן הידור, והוא אינו משתנה
בזמן ריצה. הקישור בין שמות משתנים למימוש שלהן גם הוא נעשה בזמן הידור, אבל בזמן
ריצה יש צורך בגישה למימוש של המשתנה, כלומר לכתובתו בזיכרון, ולחלץ מכתובת זו את
תכנו הנוכחי.

§§ יצוג עצי שיערוך באמצעות ביטויי~S
\פנה|איור:עץ| הוא, בסופו של דבר, כתיב שונה לביטוי \LR{\tt f(2) ?
g(++a,--b,-sin(c)) : 10+h()}. הצגת הביטוי כעץ מאפשרת לראות את תתי הביטויים המופיעים
בביטוי, ואת האילוצים לגבי סדר החישוב של תתי הביטויים הללו. החישוב של תת-ביטוי
מסויים משמעו הפעלת הפונקציה המצויה בצומת שהיא שורש העץ של תת-הביטוי, על תתי ביטויים
המקוננים בתוכו.

כתיב אחר עבור ביטויים הוא \ע|הכתיב הפולני|, הנקרא כך כיוון שפותח על ידי מדען
פולני, יאן לוקשביץ' שמו. בכתיב זה, הידוע גם בשם \ע|כתיב תחילי| (\E|prefix
notation|) הן פונקציות והן אופרטורים נכתבים לפני האופרנדים שלהם. כדי להציג את
ביטוי מסויים בכתיב הפולני יש לייצג אותו כעץ שיערוך, ואחר כך, לסרוק את העץ באופן
הבא: התחלת הסריקה היא מהשורש של העץ, וממשיכה בבנים של כל צומת לפי סידרם, אולם
\ע|טרם| שהסריקה מגיעה לבנים, היא רושמת את שם הפונקציה או האופרטור המופיע בצומת.
אם הצומת הוא עלה, יש לרשום את תוכנו.

מסריקה כזו של העץ שב\פנה|איור:עץ| תיתן את הכתיב התחילי הבא
לביטוי~\ref{eq:infix}
\begin{equation}
  \label{eq:prefix}
  \texttt{?:~f~2 g++~a~--~b~- sin c~+~10 h}
\end{equation}

\ע|הכתיב הפולני ההפוך| הקרוי גם \ע|כתיב סופי| (\E|postfix notation|) של ביטוי, בו
האופרטורים נכתבים לאחר האוררנדים, מתקבל אם תוכן הצומת נרשם \ע|לאחר| שכל בניו
נסרקו. סריקה כזו של עץ השיערוך שבאיור נותנת את הכתיב הפולני ההפוך
של~\ref{eq:infix}
\begin{equation}
  \label{eq:postfix}
  \texttt{2~f~a~++~b~--~c~sin~-~g~10~h~+~?:}
\end{equation}
הכתיב הפולני ולכתיב הפולני ההפוך מציעים יתרונות דומים לאילו המצויים שבהצגת
ביטוי כעץ שיערוך, וזאת לעומת הכתיב המקובל של ביטויים (הידוע בשם כתיב \E|infix|):
האילוצים על סדר החישוב ברורים, אין צורך בשימוש בסוגריים, ואין צורך בכללי קדימות
או אסוציאטיביות בעבור האופרטורים.
חיסרון של שתי שיטות הכתיב הפולני הוא הדרישה כי מספר האופרנדים עליהם מופעל
אופרטור, כמו גם המקומיות של כל פונקציה המופיעה בכתיב יהיו ידועים.

ישנן כמה וכמה שפות תכנות המבוססות על הכתיב הפולני ההפוך, ובהן פורת' (\E|Forth|)
ופוסטסקריפט (\E|PostScript|). שפת ליספ אימצה את הכתיב הפולני, אך בתוספת סימני
סוגריים מסביב לכל תת ביטוי, וזאת בכדי לאפשר פונקציות ואופרטורים המופעלים על על
מספר לא קבוע של אופרנדים. בבדיחות הדעת כונתה שיטת הכתיב של ליספ בשם \ע|הכתיב של
קיימברידג'| וזאת על שמה של העיר בה נמצאת אוניברסיטת MIT אשר בה פותחה השפה.
הביטוי~\ref{eq:infix} בכתיב של קיימברידג' נראה כך:
\begin{lstlisting}[
mathescape=true,
columns=fullflexible,
basicstyle=\ttfamily\scriptsize,
backgroundcolor=\color{white},
frame=none]
  (?: (f~2) (g (++a) (--b) (- (sin c)) (+10 (h)))
\end{lstlisting}
כתיב זה של שפת ליספ הוא למעשה יצוג טקסטואלי של מבנה עץ השיערוך, לפיו כל תת עץ
עטוף בזוג סוגריים. קל לראות זאת אם נשווה את \פנה|איור:עץ| לכתיבת הביטוי בשפת
\E|C|~\ref{eq:infix} בכתיב של ליספ, כך שתשתרע כך שתשתרע על מספר שורות, תוך
שימוש בהזחה כדי להציג קינון של זוגות סוגריים:

\begin{LTR}
\scriptsize
\lstinputlisting[
language=Lisp,
mathescape=true,
columns=fullflexible,
keepspaces=true,
basicstyle=\ttfamily\small,
backgroundcolor=\color{white},
frame=none]{evaluation-trees-lisp-example}
\end{LTR}

כתיבה זו מחדש נראית כעץ שב\פנה|איור:עץ| לאחר שיקוף ורבע סיבוב כנגד כיוון השעון.

אם ביטוי~\E|S| הוא רשימה של רשימות, אזי ניתן להציגו כעץ. התרגום מתבצע על ידי
הפיכת כל רשימה בביטוי לתת-עץ: האיבר הראשון ברשימה הוא שורש תת-העץ. שאר האיברים
ברשימה, הם הבנים של תת העץ. לדוגמה, בעבור הרשימה
\begin{LISP}
  (a b (car x) (+¢¢ b x))
\end{LISP}
מבנה העץ
\begin{LTR}
  \scriptsize
  \forestset{%
    x tree/.style={%
        font=\ttfamily,
        for tree={%
            s sep'+=-3pt,
            circle,
            fit=band,
          },
      },
  }
  \begin{forest}
    x tree [a,
        [a,[car,[x]]]
          [+, [b] [x]]
      ]
  \end{forest}
\end{LTR}

נשים לב לכך שהפונקציה \E|car|, כשהיא מופעלת על עץ מעל אלפאבית, היא מחזירה את
תוכנו של הצומת שבשורש העץ, ואילו הפונקציה \E|cdr| מחזירה את רשימת הבנים של
הצומת, שכל אחד מהם הוא עץ כזה בעצמו.

\begin{figure}[H]
  \caption[קידוד עץ שיערוך כביטוי~S]{
    קידוד באמצעות ביטוי~S של עץ השיערוך \פנה|איור:עץ| של הביטוי בשפת~\LR{C}: \LR{\tt f(2) ?
g(++a,--b,-sin(c)) : 10+h()}
}
\תגית|איור:קידוד|
\scriptsize
\centering
\input Forests/evaluation-tree-as-S-tree.tikz
\end{figure}

בשפה העוברת אינטרפטציה, גם משמעות הסימבולים שבעץ השיערוך וגם החישוב שלו נעשים
בזמן ריצה. נבין יותר את תהליך השיערוך לאחר שנבחן את האופן שבו הוא מתבצע בשפת
ליספ.

\begin{minipage}{0.9\textwidth}
  \centering
\newcommand\exception[1]{{\textcolor{red}{#1}}}
\begin{mdframed}[backgroundcolor=Lavender!20]
  \footnotesize
  בהינתן ביטוי מורכב \E|$s$|, אלגוריתם השיערוך של ליספ מנסה
  להציג אותו כרשימה בת~$n+1$ איברים \[
    s=(s₀\;\;s₁\;\;⋯\;\;sₙ).
\] \begin{enumerate}
    ✦ \exception{
      אם הביטוי אינו רשימה, כלומר, אם הביטוי הנתון הוא \E|dotted pair| (כמו
      \E|(a.b)| למשל) השיערוך נכשל.}
    ✦ אם הרשימה ריקה, תוצאת השיערוך היא האטום \T|nil|.
    ✦ אחרת, המשערך מסתכל על הרשימה כעל עץ שיערוך, כלומר כעל קריאה
    לפונקציה~$s₀$ המקבלת~$n$ ארגומנטים \E|$s₁$,…,$sₙ$|, והשיערוך של~$s$ מתבצע
    על פי הסתכלות זו:
    \begin{quote}
      \begin{enumerate}
        ✦ \ע|שיערוך רקורסיבי של~$s₀$, הפונקציה אותה יש להפעיל.|
        \begin{itemize}
          ✦ \exception{אם השיערוך של~$s₀$ נכשל, אזי גם השיערוך של~$s$ נכשל.}
          ✦ אחרת, שיערוך זה מחזיר ביטוי~\E|S| שנסמן~$s₀'$.
          ✦ \exception{השיערוך של~$s$ נכשל אם~$s₀'$ אינו פונקציה.}
          ✦ \exception{השיערוך של~$s$ נכשל גם אם~$s₀'$ הוא פונקציה, אך כזו
            שאינה מצפה ל-$n$ ארגומנטים בדיוק.}
        \end{itemize}
        ✦ \ע|שיערוך הארגומנטים.|
        \begin{itemize}
          ✦ המשערך ממשיך כעת לשערך רקורסיבית את הארגומנטים לפונקציה~$s₀'$,
          הלא הם הביטוים~\E|$s₁$,…,$sₙ$|. נסמן את תוצאות השיערוך הללו
          ב-\E|$s₁'$,…,$sₙ'$|.

          ✦ \exception{אם השיערוך הרקורסיבי של אחד מבין
            הביטוים~\E|$s₁$,…,~$sₙ$| נכשל, אז גם השיערוך של הביטוי~$s$ כולו
            נכשל.}
        \end{itemize}

        ✦ \ע|הפעלת הפונקציה על הארגומנטים.|

        \begin{itemize}
          ✦ תוצאת השיערוך של הביטוי~$s$ היא תוצאת הקריאה לפונקציה~$s₀'$
          על~$n$ הביטוים \E|$s₁'$,…,~$sₙ'$|.

          ✦ \exception{אם הפעלה זו נכשלת, השיערוך של הביטוי~$s$ כולו נכשל.}
        \end{itemize}
      \end{enumerate}
    \end{quote}
  \end{enumerate}
\end{mdframed}
\end{minipage}

נשים לב לכך שכל ביטוי בשפת פסקל (למשל) ניתן להצגה כעץ שיערוך, וכי כל עץ שיערוך
ניתן להצגה כרשימה של רשימות. אולם, לא כל רשימה של רשימות ניתנת להצגה כעץ
שיערוך. בפרט, אם הפריט הראשון ברשימה הוא בעצמו רשימה, כמו למשל כאן,
\begin{LISP}
((car (f g)) x)
\end{LISP}
אזי לא ניתן להציג את הרשימה כולה כעץ שיערוך. הסיבה לכך היא שהטופולוגיה של עצי
השיערוך בה עשינו שימוש מניחה שבכל צומת פנימי של העץ, ישנה תגית, המציינת את
הפונקציה שיש להפעיל בצומת זה. אולם

§§ שיערוך דחוי
אלגוריתם השיערוך כפי שתואר עד כה אינו מספיק כדי לשערך את העץ ב\פנה|איור:עץ|
כהלכה. הסיבה היא שהאופרטור הטרנארי \LR{\texttt{$·$?$·$:$·$}} אשר מצוי בשורש העץ, מחשב את
הארגומנט
הראשון שלו, ובהתאם לתוצאת החישוב, מחשב את הארגומנט השני או השלישי, אבל לא את
שניהם גם יחד. למימוש של האופרטור הטרנארי

בפרוצדורת השיערוך שתוארה למעלה, יש לחשב את כל הארגומנטים לפונקציה
(או אופרטור), טרם שמפעילים את הפונקציה עצמה.

אלגוריתם השיערוך גם אינו מתאים לפונקציות כגון quote ו-lambda אשר אינן משערכות
את הפרמטרים שלהן כלל. הפרוצדורה גם אינה מתאימה לפונקציות כגון cond בהן השיערוך
של חלקים מגוף הפונקציה תלוי בערכים המחושבים בחלקים אחרים של הגוף.

§§ שיערוך דחוי
אלגוריתם השיערוך כפי שתואר עד כה אינו מספיק כדי לשערך את העץ ב\פנה|איור:עץ|
כהלכה. הסיבה היא שהאופרטור הטרנארי \LR{\texttt{$·$?$·$:$·$}} אשר מצוי בשורש העץ, מחשב את
הארגומנט
הראשון שלו, ובהתאם לתוצאת החישוב, מחשב את הארגומנט השני או השלישי, אבל לא את
שניהם גם יחד. למימוש של האופרטור הטרנארי

בפרוצדורת השיערוך שתוארה למעלה, יש לחשב את כל הארגומנטים לפונקציה
(או אופרטור), טרם שמפעילים את הפונקציה עצמה.

אלגוריתם השיערוך גם אינו מתאים לפונקציות כגון quote ו-lambda אשר אינן משערכות
את הפרמטרים שלהן כלל. הפרוצדורה גם אינה מתאימה לפונקציות כגון cond בהן השיערוך
של חלקים מגוף הפונקציה תלוי בערכים המחושבים בחלקים אחרים של הגוף.

אנו מבדילים בין שני סוגים של סמנטיקות של שיערוך של פונקציה:
\begin{description}
  ✦ [eager] בקריאה לפונקציה כגון set שהסמנטיקה שלה היא \E|eager|, הארגומנטים
  לפונקציה משוערכים \ע|טרם| הקריאה לפונקציה, ורק ערכי השיערוך מועברים לפונקציה.
  הפונקציה אינה יכולה לדעת מה היו ערכי הארגומנטים לפני ששוערכו.

  פונקציות בעלות סמנטיקה שהיא eager מיוצגות על ידי ביטוי~$λ$ שהאטום הראשון שבו
  הוא \T|lambda|.

  ✦ [normal] לעומת זאת, בקריאה לפונקציה כגון quote שהסמנטיקה שלה היא
  \E|normal|, הארגומנטים לפונקציה \ע|אינם| משוערכים טרם הקריאה לפונקציה,
  והפונקציה יכולה לבחור אם לשערך את הארגומנטים.

  פונקציות בעלות סמנטיקה שהיא normal מיוצגות על ידי ביטוי~$λ$ שהאטום הראשון שבו
  הוא האטום \T|nlambda|.†{%
  שימוש זה ב-nlambda היה קיים במימושים הראשונים של ליספ, אולם ברוב המימושים המודרניים
  הוא בוטל מסיבות של יעילות. במקומו, נוסף מה שקוראים מקרו \E|(macro)|
  שהוא דומה אך לא זהה ל-\E|nlambda|.}

  כלומר, אנו מבחינים בין שני סוגים של ביטויי~\E|$λ$| בליספ: כאלו שמשערכים את
  הפרמטרים שלהם לפני הפעלתם והמסומנים על ידי האטום \T|lambda| וכאלו שאינם עושים
  זאת, והמסומנים על ידי האטום \T|nlambda|.
\end{description}

הסמנטיקה של \ע|כל הפונקציות| וכמעט כל האופרטורים בשפות כמו \E|\CPL|, היא
\E|eager|. כמפורט ב\פנה|טבלה:אטומיות| שבהמשך, הסמנטיקה של כל הפונקציות
האטומיות של מיני-ליספ היא \E|eager|, זאת מלבד הפונקציה \E|cond|, אשר הסמנטיקה
שלה היא \E|normal|. הסיבה לכך היא ש-cond מדמה במיני-ליספ את פקודת התנאי \E|(if
command)| של שפות אחרות. למעשה, cond מכלילה את האופרטור הטרנארי
\LR{\texttt{$·$?$·$:$·$}}, כך שיוכל לבדוק מספר תנאים, ולא תנאי אחד בלבד.

אנו מבדילים בין שני סוגים של סמנטיקות של שיערוך של פונקציה:
\begin{description}
  ✦ [eager] בקריאה לפונקציה כגון set שהסמנטיקה שלה היא \E|eager|, הארגומנטים
  לפונקציה משוערכים \ע|טרם| הקריאה לפונקציה, ורק ערכי השיערוך מועברים לפונקציה.
  הפונקציה אינה יכולה לדעת מה היו ערכי הארגומנטים לפני ששוערכו.

  פונקציות בעלות סמנטיקה שהיא eager מיוצגות על ידי ביטוי~$λ$ שהאטום הראשון שבו
  הוא \T|lambda|.

  ✦ [normal] לעומת זאת, בקריאה לפונקציה כגון quote שהסמנטיקה שלה היא
  \E|normal|, הארגומנטים לפונקציה \ע|אינם| משוערכים טרם הקריאה לפונקציה,
  והפונקציה יכולה לבחור אם לשערך את הארגומנטים.
  \end{description}
 
