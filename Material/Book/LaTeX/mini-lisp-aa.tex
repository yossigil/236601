§§ מיני-ליספ היא ליספ מינימלית 
שפת ליספ היא שפת תכנות פעילה, עשירה במבנים חדשים ומתקדמים כגון תכנות מונחה
עצמים, פעילה ויעילה. אין כאן ניסיון ללמד שפה זו, ובוודאי אין כאן גם ניסיון
להפוך את הקורא למתכנת באחד מהניבים הנפוצים או הפחות נפוצים של ליספ. במקום זאת,
נציג כעת גלעין \E|(core)| מינימלי ביותר של השפה. גלעין זה נבחר בקפידה כך שידגים
כל התכונות החשובות של ליספ, ובכללם ביטויי \E|S| ושיערוך כמובן, את פרדיגמת
התכנות הפונקציונלית, ומושגים חשובים נוספים, וזאת מבלי להעמיס על הקורא כל פרט
אשר אינו חיוני להדגמה זו.

הניב של ליספ הבנוי על גלעין זה קרוי \ע|מיני-ליספ|, ובאנגלית, \E|Minimal~Lisp|
או בקיצור \E|Mini Lisp|, או \E|m-Lisp|. למעט הבדלים פעוטים, תכנית מיני-ליספ
היא, בדרך כלל, תכנית חוקית של \E|Common Lisp|. אבל, בדרך כלל, תכנית של
\E|Common Lisp| אינה תכנית חוקית של מיני-ליספ.

הניבים השונים של ליספ משתמשים גם הם \פנה|הגדרה:S| ביטויי-\E|S|, אלא שהם מוסיפים
עליה קיצורים שונים. במיני-ליספ נשתמש בשני קיצורים:
\אבגד
✦ כתיב הרשימות, שיוצג כאן
✦ סימן ה-\E|quote| \E|(')|, שיוצג בהמשך ב\פנה|פרק:quote|
===

בניגוד לניבים האחרים של ליספ, שפת מיני-ליספ אינה תומכת במספרים ובפעולות
אריתמטיות, והיא מזניחה את ענין היעילות כמעט לחלוטין: לא נעשה כל מאמץ להבטיח כי
המימוש של מיני-ליספ יהיה יעיל. רוב הניבים של ליספ, יודעים להדר, באופן
חלקי או מלא, תכניות ליספ לשפת מכונה. גם הידור כזה אינו נחוץ במיני-ליספ.

על אף המינימליות של שפת מיני-ליספ, השפה היא מה שקרוי שפה "אוניברסלית". היותה של
השפה אוניברסלית, משמעותה היא כי ניתן לכתוב במיני-ליספ כל תכנית שאפשר לכתוב
בשפות תכנות סגפניות פחות ממנה, כמו פסקל ו-\E|C| למשל. כך ניתן להוסיף למיני-ליספ
תמיכה במספרים טבעיים. באופן דומה ניתן להרחיבה כך שתתמוך במספרים שליליים,
רציונליים, ממשיים, מרוכבים, וגם מחרוזות, מבני נתונים, מערכים, כמו גם בתכונות של
ניבים אחרים של ליספ, או אף שפות אחרות. \פנה|פרק:אוניברסליות| שבהמשך ירחיב את
הדיון באוניבסליות של שפות תכנות.

לא זו בלבד שהביצוע של תכניות בשפת מיני-ליספ אינו יעיל, גם תכנות בשפה רחוק
מלהיות נוח, בהעדר, למשל, תמיכה מובנית בפעולת החיבור או בפעולות קלט/פלט. אכן,
שפת מיני-ליספ אינה משמשת לתכנות של ממש. היא פותחה לצרכיו של סיכום זו, והיא אינה
מתוכננת לשימוש מעבר לתירגול החומר.

לעומת זאת, מיני-ליספ יעילה מאוד ללימוד, וניתן להכיר אותה על בוריה בתוך שעות
ספורות לכל היותר: לבד מאלגוריתם השיערוך והכתיב הפשוט של ביטויי~\E|S|, יש להכיר
גם פונקציות בסיסיות ספורות מהן נבנות תכניות במיני-ליספ.

§§ המרכיבים של מיני-ליספ
ישנם שלושה מרכיבים עיקריים למיני-ליספ:
\begin{description}
  ✦ [פונקציות אטומיות.] אילו הן פונקציות פשוטות אשר הן "אקסיומטיות", כלומר,
  הגלעין מניח שהן קיימות וכי הן מצייתות למפרט מוגדר היטב. אולם, האופן שבו
  ממומשות הפונקציות האטומיות אינו חלק ממיני-ליספ.

  לעיתים קוראים לפונקציות האטומיות גם \ע|פונקציות פרימיטיביות|, במובן זה שהן
  הבסיסיות ביותר. אנחנו נעדיף את המינוח "האטומי", המדגיש את העובדה שהן בלתי
  ניתנות ל-"חלוקה", ואם נעיין בקרבי המימוש שלהן, לא נמצא שם פונקציות אחרות של
  מיני-ליספ, אלא מבנים אחרים.

  ✦ [פונקציות מוגדרות מראש.] בנוסף לפונקציות האטומיות, מציעה שפת מיני-ליספ
  לנוחות המשתמש בה מספר פונקציות נוספות, אשר אותן מממש הגלעין באמצעות קריאה
  לאחת או יותר מהפונקציות האטומיות.

  בבדיקה השוואתית של שפות תכנות, נבחין בין פונקציות מוגדרות מראש ובין
  \ע|פונקציות ספרייה|. ספרייה של פונקציות היא אוסף של פונקציות המאורגנות יחד
  והממוממשות באמצעות האטומים של השפה. המשמשות למטרה קרובה או דומה. המשתמש בשפה
  רשאי, אך אינו חייב להשתמש בספרייה, ולכן פונקציות הספרייה הן אופציונליות
  בעבורו. לעומתן, קבוצת הפונקציות המוגדרות מראש בשפה היא חלק מהגדרת שפת התכנות,
  והמשתמש אינו יכול לבחור אם להשתמש בה אם לאו.

  בשפת התכנות~\CPL אין פונקציות מוגדרות מראש. גם פונקציה בסיסית כגון printf
  המשמשת להוצאת פלט ממוממשת כחלק מספרייה. ישנן סיפריות רבות לשפת~\CPL, אך
  הספרייה אשר מכילה את הפונקציה printf היא יחודית בכך שהיא קרויה \ע|הספרייה
  הסטנדרטית| (בה' הידיעה), או \E|libc|. מקובל לכלול את \E|libc| כחלק
  מתכניות~\CPL. אולם, ניתן לכתוב תכניות~\CPL גם מבלי להשתמש בספרייה זו, וישנן
  תכניות שימושיות שאינן משתמשות כלל בסיפריות של השפה.

  המקבילה בפסקל לפונקציה printf בשפת~\CPL, היא הפרוצדורה הידועה בשם
  \E|WriteLn|. פרוצדורה זו מוגדרת מראש בשפה. לא ניתן לכתוב תכנית פסקל אשר אינה
  כוללת את \E|WriteLn|, אם כי המתכנת אינו חייב להשתמש בפרוצדורה זו, והוא אף
  יכול להשתמש בשם \E|WriteLn| לצרכיו, ובכך להסתיר את הפרוצדורה המקורית.

  ✦[אלגוריתם השיערוך] שפת מיני-ליספ, כמו בניבים אחרים של ליספ, מכילה פונקציה
  מיוחדת, \E|eval| שמה, אשר מקבלת ביטוי~\E|S| ומשערכת אותו. מסיבות טכניות
  (עליהן נעמוד בקצרה בהמשך) הפונקציה eval נחשבת אף היא פונקציה אטומית, אולם, את
  רובה ככולה ניתן לממש כפונקצית ספרייה.
\end{description}

§§ הפונקציות האטומיות
כל הפונקציות האטומיות של מיני-ליספ הן גם פונקציות אטומיות של מרבית הניבים
החשובים של ליספ, ובפרט של \E|Common Lisp|, אם כי יתכנו הבדלים קלים במשמעות של
הפונקציות האטומיות בין מיני-ליספ ובין הניבים השונים.

בניבים אחרים של ליספ, יש בדרך כלל מספר רב של פונקציות אטומיות נוספות. לעומת
זאת, יש במיני-ליספ שמונה פונקציות אטומיות בלבד (למעט \E|eval|):
\ציינן
✦ \ע|שלוש פונקציות מבניות|: \E|car|, \E|cdr| ו-\E|cons|, אשר מאפשרות ליצור
ביטוי \E|S| משני ביטויים אחרים ולפרק אותו לשני לחלקיו.

✦ \ע|שתי פונקציות לוגיות|: \E|atom| ו-\E|eq| המאפשרות לבדוק את תוכנו של
ביטוי~\E|S|.

✦ \ע|שלוש פונקציות נוספות|:
\begin{itemize}
    ✦ הפונקציה \E|set| המאפשרת לתת שמות לביטויי~\E|S|, ולאפשר למתכנת להגדיר
      פונקציות נוספות משלו.
      ✦ הפונקציה \E|cond| המשמשת לצורך חישוב מותנה,
      בדוגמה לפקודות התנאי בשפות תכנות אחרות.
      ✦ הפונקציה \E|error| המסייעת בטיפול במקרים שבהם החישוב נתקל בשגיאה.
\end{itemize}
===

הערכים בהם מטפלת שפת ליספ הם ביטויי~\E|S|, ונדרשות במיני-ליספ שמונה פונקציות
אטומיות כדי לבצע את כל המניפולציות הנחוצות של ערכים אלו, וביניהן פעולה המקבילה
להצבה ופעולה המקבילה להדפסת שגיאה. בהשוואה לאלו, התמיכה של שפת פסקל בטיפוס של
מספרים שלמים משתמשת ב-14 פריטים שונים:~5 אופרטורים אריתמטיים בינאריים,~2
אופרטורים אריתמטיים אונאריים,~6 אופרטורים של השוואה, וכן סימן מיוחד, \E|:=|,
אשר אינו נחשב לאופרטור בשפת פסקל, לציון פעולת ההצבה. (שפת פסקל אינה מציעה תמיכה
יחודית לתמיכה בשגיאות).

\פנה|טבלה:אטומיות| שבהמשך מתארת את הפונקציות האטומיות במדויק. מיני-ליספ מעלה
על נס את המינימליות, ואכן למרות שהטבלה מביאה מפרט מלא של הפונקציות הללו ואת כל
מה שנדרש כדי להשתמש בהן, היא אינה משתרעת על פני יותר ממחצית העמוד. (יש עדיין
צורך בכמה הגדרות וסימונים כדי לקרוא את הטבלה ולהבין את משמעות~8 הפונקציות בה,
אולם ניכר כי תיאורן קצר.)

אנו נתאר ראשית את הפונקציות המבניות, ואחר כך את הפונקציות הלוגיות \E|atom|,
ו-\E|eq| יחד עם הפונקציה המוגדרת מראש \E|null|. המשך הדיון יוביל לתיאורה של
הפונקציה \E|set|, ואחריה \E|cond|. תורה של \E|error| יגיע כאשר נממש את
אלגוריתם השיערוך במיני-ליספ.

§§ פונקציות מוגדרות מראש

מיני-ליספ מכילה שמונה פונקציות מוגדרות מראש, כלומר פונקציות הכתובות בשפת
מיני-ליספ תוך שימוש בפונקציות האטומיות, ואשר נטענות תמיד יחד עם מיני-ליספ.

\ציינן
✦ \ע|קבועים| (פונקציות ללא פרמטרים):
\begin{itemize}
  ✦ \E|t| (המציין את הערך הבוליאני של אמת).
  ✦ \E|nil| (המציין את הערך הבוליאני של שקר).
\end{itemize}
✦ \ע|פונקציה לוגית|: \E|null| (פונקציה חד-מקומיות הבודקת אם ביטוי הוא \E|nil|).
✦ \ע| פונקציות המסייעות בהגדרת פונקציות|:
\E|quote|, \E|defun|, \E|ndefun|, \E|lambda| ו-\E|nlambda|.
\begin{itemize}
  ✦ הפונקציה defun משמשת להגדרת פונקציות חדשות.
  ✦ הפונקציה quote משמשת למניעת השיערוך של ביטויי~\E|S|.
  ✦ בפונקציות \E|ndefun|, \E|lambda| ו-\E|nlambda|, נדון בהמשך.
\end{itemize}
===

מלבד ndefun ו-nlambda ניתן למצוא, לעיתים בשינוים קלים, את הפונקציות המוגדרות
מראש של מיני-ליספ גם ב-\E|Common lisp| ובניבים אחרים של השפה.
\פנה|טבלה:מראש| שבהמשך מתארת את הפונקציות המוגדרות מראש, והיא כוללת, בנוסף
לתיאור הפונקציות הללו, גם את המימוש המלא שלהן במיני-ליספ, ובכל זאת, טבלה זו
קצרה אף יותר מ\פנה|טבלה:אטומיות| המתארת את הפונקציות האטומיות.

בהמשך נראה כי מימושן של הפונקציות המוגדרות מראש נעשה באמצעות קשירה
(\E|binding|) של שמן למה שקרוי "ביטוי \E|lambda|" או "ביטוי \E|nlambda|",
באמצעות הפונקציה \E|set| (ישירות או בעקיפין). במונח binding אנו מתכוונים לקישור
בין שם לבין המשוים אותו מציין השם. נניח ש-$f$ היא פונקציה מוגדרת מראש. אזי~$f$
היא ביטוי~\E|S| שהוא מהצורה המיוחדת של ביטוי \E|lambda| או מהצורה המיוחדת של
ביטוי \E|nlambda|. מתן שם למשוים~$f$ הוא הקישור בין אטום של מיני-ליספ (שהוא
השם) למשוים~$f$.

קישור של שם למשוים קיים בכל שפות התכנות: כאשר אנו מגדירים בשפת תכנות כמו פסקל
משתנה אשר שמו הוא \T|i|, אנו נותנים שם לתא בזכרון שמכיל את ערכו של המשתנה.
המשוים הוא תא בזיכרון שמכיל את ערכו של המשתנה, ו-\T|i| הוא השם שאנו קושרים לתא
זה. המונחים קישור והגדרה הם זהים: פונקציות מוגדרות מראש בשפת מיני-ליספ הן
פונקציות אשר הקישור בין שמן ובין הגוף שלהן נעשה עוד טרם ריצת התכנית. כאשר אנו
אומרים שהסימן \T|+| מציין את פעולת החיבור בשפת פסקל, אנו בעצם אומרים שיש קישור
בין הסימן ובין הפעולה. גם הסימן \T|+| וגם \T|i| הם שמות של משוימים. הסימן~\T|+|
מציין משוים שהוא פעולה, ואילו \T|i| מציין משוים שהוא משתנה. הבדל אחד, אך לא
הבדל מהותי, בין~\T|+| ובין~\T|i| הוא שלמתכנת (בשפת פסקל לפחות) אין אפשרות
להשתמש בסימן~\T|+| כדי לציין משוימים שהוא יצר.

הדיון כאן יתאר תחילה את הקבועים, כלומר הפונקציות האפס-מקומיות, \E|t| ו-\E|nil|,
ולאחר את הפונקציה החד-מקומית \E|null|. אחר כך נעבור לתאר את \E|quote|, את
\E|defun| ואת \E|lambda|. הפונקציות \E|ndefun| ושל \E|nlambda| דורשות מעט יותר
תשומת לב, והן תוצגנה אחרונות.

§§ האינטרפרטר של ליספ
אנו רואים כי המונח שיערוך כולל בתוכו שני מרכיבים עיקריים: ראשית, איתור המשמעות
של הסמלים המופיעים בביטוי, ושנית, חישוב הביטוי בהתאם למשמעות זו.

בדרך כלל מרכיב החישוב של השיערוך מחשב ביטוי חדש, אך לעיתים השיערוך מייצר משמעות
בעבור סמלים שלא הייתה להם משמעות טרם השיערוך: השיערוך אינו לקוח בלבד
בלבד של הגדרות הסמלים, הוא גם עשוי לייצר הגדרות חדשות כאלו.

בשפות תכנות כדוגמת~\CPL ופסקל, העוברות \ע|הידור| \E|(compilation)| שני מרכיבי
השיערוך נפרדים. מתן המשמעות לסמלים ואיתור המשמעות של סמלים נעשה על ידי
ה\ע|מהדר| \E|(compiler)|. החישוב עצמו נעשה בזמן ריצת התכנית. בליספ, כמו בשפות
אחרות שבהן עיבוד התכנית בשפה נעשה באמצעות אינטרפרטציה \E|(interpretation)| של
תכניות, שני השלבים של השיערוך נעשים על ידי האינטרפרטר \E|(interpreter)| אשר
קורא תכניות ומשערך אותן בזו אחר זו. האינטרפרטציה כוללת לכן לא רק את תהליך
החישוב, אלא גם את התהליכים הנלווים של מתן משמעות לסמלים, ואיתור משמעות זו.

\begin{minipage}{0.9\linewidth}
  \centering
  \footnotesize
\begin{mdframed}[backgroundcolor=Lavender!20]
    האינטרפרטר של ליספ, כמו תכנת מאקסימה (\פנה|איור:מאקסימה|), האינטרפרטר של
    פרולוג, \E|bash| ושפות תכנות אחרות העוברות אינטרפרטציה, עובד במחזורים,
    בשיטה הידועה בשם
    \LR{\textbf Read \textbf Evaluate \textbf Print \textbf Loop}
    או בראשי תיבות \E|REPL|:
    \ספרר
    ✦ \E|READ|: האינטרפרטר קורא סידרת תווים מהקלט, ומנסה להציג סידרה זו כמבנה
    בשפת התכנות. במקרה של ליספ, האינטרפרטר קורא סדרת תווים, ומנסה להציג
    אות כביטוי~\E|S|. אם לא ניתן לעשות כן, האינטרפרטר מדפיס הודעת שגיאה וחוזר
    לתחילת הלולאה של \E|REPL|, כלומר חוזר לקרוא קלט חדש.
    ✦ \E|EVALUATE|: האינטרפרטר משערך את ערכו של הביטוי שקרא.
    ✦ \E|PRINT|: אם השיערוך של הקלט מצליח, אז האינטרפרטר ידפיס את תוצאת
    השיערוך. אחרת, האינטרפרטר ידפיס הודעת שגיאה מתאימה.
    ✦\E|LOOP|: האינטרפרטר חוזר לצעד הראשון, לקריאת הקלט הבא.
===
  \end{mdframed}
\end{minipage}

\פנה|איור:REPL| מביא את הקוד שמממש את ה-\E|REPL| באינטרפרטר של מיני-ליספ.
\begin{figure}[H]
\כיתוב|מימוש REPL בתוך האינטרפרטר של מיני-ליספ|
\תגית|איור:REPL|
\input mini-lisp-REPL.tex
\end{figure}


כפי שאפשר לראות באיור, האינטרפרטר של ליספ מכיל שלושה מרכיבים עיקריים:
\begin{enumerate}

  ✦ ה-Reader אשר קורא קלט מתוך זרם של תווים, מנתח אותו כתיאור טסקטואלי של
  ביטוי~S, ומחזיר מבנה נתונים המקודד את ביטוי ה-S.  לביטוי ה-\E|S|
  המתאים
  לתווים אלו. באיור, מרכיב זה הוא הפונקציה \mini{read()},
  אשר מזרזת את המשתמש באינטרפרטר להזין קלט תקין, מעירה לו אם הקלט אינו תקין
  ומזרזת אותו שוב, עד אשר מתקבל קלט שהוא ביטוי כזה.

  אם לא ניתן לקבל יותר קלט, פונקציה זו אינה מחזירה תוצאה, כלל. במקום זאת היא
  "זורקת" \ע|חריגה| (\E|exception|). במקרה זה, אין אפשרות להמשיך בלולאת
  ה-\E|REPL|, והחישוב מסתיים.

  ✦ המשערך \E|(Evaluator)| אשר משערך ביטויי~\E|S| אלו. באיור, מרכיב זה הוא
  הפונקציה \mini{eval()}, אשר מקבלת ביטוי לשיערוך, ומחזירה את תוצאת השיערוך.

  אם השיערוך נכשל, פונקציה זו אינה מחזירה ערך, אלא זורקת חריגה, שגם היא במבנה
  של ביטוי~\E|S|. כשלון בשיערוך של ביטוי מסויים אינו מפסיק את מחזורי
  ה-\E|REPL|.

  השיערוך יכול להיכשל גם מסיבות של כשל "תשתיתי", בעיקר כאשר כאשר משאבי הזיכרון
  הנדרשים לו גדולים מאלו העומדים לרשות האינטרפרטר. כישלון מסוג זה יביא לסיום עבודתו
  של האינטרפרטר.

  ✦ ה-Printer אשר מקבל ביטוי~\E|S| כמבנה נתונים ומתרגם אותו לסדרת תווים אשר
  מייצגת מבנה נתונים זה. בפנה|איור:REPL| מרכיב זה הוא הפונקציה \mini{println()}.
\end{enumerate}

כאן נניח שה-Reader וה-Printer נתונים והם דומים לאלו שבכל ניב של ליספ, ונעסוק
בעיקר במשערך של מיני-ליספ.

המשמעות של המונח \ע|כתיב| היא שמרכיב ה-Reader של האינטרפרטר של ליספ יכול לקרוא
ביטויי~\E|S| הנתונים בכתיב הרשימות ושמרכיב ה-Printer של האינטרפרטר יתרגם
ביטוי~\E|S| לכתיב הרשימות כשהדבר אפשרי (לא כל ביטוי~\E|S| ניתן להיכתב בכתיב
הרשימות; למשל הביטוי \E|(a.b)| אינו ניתן להכתב כרשימה, אבל כל רשימה ניתנת
להיכתב כביטוי~\E|S|). בהעדר סיבה מיוחדת, מתכנתי ליספ נוהגים לכתוב ביטויי~\E|S|
בכתיב הרשימות בכל אימת שניתן לעשות זאת.

ראינו שביטויי~\E|S| ניתנים להצגה כעץ בינארי שבו העלים, והעלים בלבד, מכילים
סמלים. אם ביטוי~\E|S| ניתן להכתב כרשימה של רשימות, אז ניתן להציג את הביטוי
הזה כ\ע|עץ| שבו קיים סמל בכל צומת פנימי ובכל עלה, ומספר הבנים של כל צומת פנימי
יכול להיות כלשהו.
