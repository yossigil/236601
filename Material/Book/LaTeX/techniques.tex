\def\Title{טכניקות לניתוח שפות תכנות}
\input wrap

§§ ניתוח לקסיקלי וניתוח דקדוקי
הבחנו בין ביטוי סימבולי, שאין משמעות מוגדרת מראש לסמלים המופיעים בו, ובין ביטוי
שאינו סימבולי, למשל ביטוי מתימטי כגון~$3²+4²$, או ביטוי המופיע בשפת תכנות
כדוגמת פסקל. בביטוי שאינו סימבולי, משמעות הסמלים ידועה. כפי שנראה כאן, את שני
סוגי הביטויים ניתן להציג כעץ מעל אלפאבית מתאים. בשני סוגי הביטויים משמעות
תגית המופיעה בכל צומת היא הפעלה של הפונקציה שאותה מייצגת התגית של
הצומת, על הבנים של הצומת. התגית שבצומת שהיא עלה מציינת פונקציה נולארית, או
אופרנד. בביטוי שאינו סימבולי הפונקציה אותה מציינת התגית היא ידועה. שיערוך של
ביטוי משמעו הפעלת פונקציה זו, אלא ששיערוך של ביטוי סימבולי דורש מציאת משמעות
הפונקציה המתאימה לתגית.

נביט על הביטוי המוזר הבא:
\begin{equation}
  \label{eq:weird}
  (\amalg⊚✠) ⊘ (\Re≀⅁)
\end{equation}
לסימנים המופיעים בביטוי אין משמעות ידועה ומוכרת לכל, ולכן בעבור מרבית הקוראים
הביטוי~\ref{eq:weird} הוא ביטוי סימבולי. אנו כמובן נניח שמשמעות שני זוגות סימני
הסוגריים המופיעים בביטוי היא כמקובל, ונשתמש בהם כדי לפענח את הביטוי. לשם כך,
נדרשת משמעות הסמלים המופיעים בו: האם הם אופרטורים בינאריים (דו-מקומיים),
אונאריים (חד מקומיים), או שמא הם אופרנדים, כלומר נולאריים (אפס-מקומיים), הקרויים
גם \ע|אופרנדים|.

אם האופרנדים בביטוי הם~$\amalg$,~$✠$,~$\Re$ ו-$⅁$, והאופרטורים
(הבינאריים) הם~$⊚$,~$⊘$ ו-$≀$, אז ניתן לתאר את מבנה הביטוי~\ref{eq:weird} כעץ
המופיע ב\פנה|איור:מוזר|.

\begin{figure}[H]
  \caption[עץ שיערוך אפשרי עבור~$(\amalg⊚✠)⊘(\Re≀⅁)$]{
    עץ שיערוך עבור~$(\amalg⊚✠) ⊘ (\Re≀⅁)$,
בהנחה ש~$\amalg$,~$✠$,~$\Re$
ו-$⅁$ הם אופרנדים,
ובהנחה ש-$⊚$,~$⊘$ ו-$≀$ הם אופרטורים בינאריים
  }
\תגית|איור:מוזר|
\centering
\scriptsize
  \begin{forest}
s tree [$⊘$,[$⊚$ [$\amalg$] [$✠$]] [$≀$[$\Re$][$⅁$]]]
  \end{forest}
\end{figure}

אולם, יתכן גם כי האופרנדים הם הסימנים~$⅁$ ו-$✠$, כלומר אלו הם אופרטורים
נולאריים, ואילו~$\amalg$,~$⊚$,~$✠$ ו-$\Re$ הם אופרטורים אונאריים (ממבנה
הסוגריים בביטוי עולה כי~$⊘$ הינו אופרטור בינארי). במקרה זה, העץ המתאר
את~\ref{eq:weird} כמופיע ב\פנה|איור:מוזר:מאוד|.

\begin{figure}[H]
\centering
\begin{quote}
  \scriptsize
  \center
  \begin{forest}
    s tree [$⊘$,[$\amalg$ [$⊚$ [$\amalg$]]]
          [$\Re$ [$≀$ [$⅁$]]]]
  \end{forest}
\end{quote}
\caption[עץ שיערוך אפשרי נוסף עבור~$(\amalg⊚✠) ⊘ (\Re≀⅁)$]{עץ שיערוך
  עבור~$(\amalg⊚✠) ⊘ (\Re≀⅁)$, כאשר הסימנים~$⅁$ ו-$✠$ הם ו-$\amalg$,~$⊚$,~$✠$
  ו-$\Re$ הם אופרטורים אונאריים,
ו-$⊘$ הינו אופרטור בינארי}
\תגית|איור:מוזר:מאוד|
\end{figure}

\ע|ניתוח דקדוקי| הוא התהליך הממיר ביטוי~\ref{eq:weird} לעצים כגון אלו
שב\פנה|איור:מוזר| וב\פנה|איור:מוזר:מאוד|. הקלט לניתוח הדקדוקי הוא סידרה של
\ע|אסימונים| (\E|tokens|). \ע|ניתוח לקסיקלי| הוא התהליך המתרגם את התווים שבקלט
לאסימונים. התהליך כולל השמטה של תווים בודדים (כגון רווחים) ואף סדרות של תווים (
כגון הערות(ואיגוד התווים שנותרו לכלל אסימונים היכולים לכלול תו אחד או יותר.

בניסיון שלנו לתהות על משמעות הביטוי~\ref{eq:weird} הנחנו שכל תו הוא אסימון
בודד. וכי סימני הסוגריים הם \ע|סימני פיסוק|, כלומר סימנים אשר אין להם תפקיד משל
עצמם, וכל מטרתם היא לסייע לניתוח הדקדוקי לפענח את הביטוי: בשני הניתוחים
הדקדוקיים של~\ref{eq:weird} אותם הצגנו מופיע תת-עץ מובחן המתאים לסידרת
האסימונים העטופה בזוג סוגריים.

גם הניתוח הלקסיקלי אינו מובן מאליו: אפשר לבנות סידרת אסימונים מסידרת התווים
$(\amalg⊚✠) ⊘ (\Re≀⅁)$ המופיעה ב-\ref{eq:weird} בדרך שונה מזו שבה בחרנו קודם:
\begin{enumerate}
  ✦ \fbox{$(\amalg$} אסימון, אשר יכול להיות אופרטור או אופרנד
✦ \fbox{$⊘$} תו ממנו יש להתעלם.
✦ \fbox{$✠)$} אסימון נוסף, אשר אף הוא יכול להיות אופרטור או אופרנד
✦ \fbox{$⊘$} אסימון המשמש כסימן פיסוק שתפקידו הוא כזה של פתיחת סוגריים
✦ \fbox{$Re≀$} אסימון שלישי אשר יכול להיות אופרטור או אופרנד
✦ \fbox{$⅁)$} אסימון המשמש כסימן פיסוק שתפקידו הוא כזה של סגירת סוגריים
\end{enumerate}

\פנה|איור:משונה| מתאר עץ שיערוך המתקבל מחלוקה זו לאסימונים,
כאשר~\fbox{$(\amalg$} ו-\fbox{$✠)$} מתפרשים כאופרטורים אונאריים, ו-\fbox{$Re≀$}
כאופרנד.
\begin{figure}[H]
  \caption[עץ שיערוך אפשרי שלישי בעבור~$(\amalg⊚✠) ⊘ (\Re≀⅁)$]{עץ שיערוך המתקבל
    בחלוקה של~$(\amalg⊚✠) ⊘ (\Re≀⅁)$ לאסימונים באופן שבו~\fbox{$(\amalg$}
    ו-\fbox{$✠)$} הם אופרטורים אונאריים, \fbox{$Re≀$} הוא אופרנד, \fbox{$⊘$}
    הוא סימן פיסוק שמשמעותו היא כשל פתיחת סוגריים, ואילו \fbox{$⅁)$} הוא סימן
    שמשמעותו היא כשל סגירת סוגריים, ו-\fbox{$⊘$} הוא תו ממנו יש להתעלם}
\תגית|איור:משונה|
\centering
  \scriptsize
  \center
  \begin{forest}
    s tree [{$(\amalg$} [{$✠)$} [{$Re≀$}]]]
  \end{forest}
\end{figure}

המונח \ע|עצי שיערוך| מתייחס לעצים כגון אלו המופיעים ב\פנה|איור:מוזר|,
ב\פנה|איור:מוזר:מאוד|, ו\פנה|איור:משונה| אשר
 מוכנים לביצוע שיערוך.

 כאמור, השיערוך כולל שני שלבים קונצפטואליים: מתן משמעות לסימבולים המופיעים בעץ,
 ואחר כך חישוב, מהעלים כלפי מעלה, של ערכה של כל צומת עלי ידי הפעלת הפונקציה
 המצויינת בצומת על הערכים שהתקבלו משיערוך הבנים של הצומת. 
ה-\E|a-list| ידועה גם בשם \ע|סביבה| (\E|\emph{environment}|). מושג הסביבה אינו
יחודי למיני-ליספ או לליספ. בכל שפת תכנות, הסביבה או ה-\E|environment| היא זו
אשר נותנת משמעות לשמות. כלומר, לדוגמה, נעיין בתוכנית הזו בשפת~\CPL:
\begin{CPP}
int main(int argc, char *[] argv, char **envp) {
  /* ¢$ℓ₀$¢ */ int i;
  for (i=1; i<argc;++i) {
    do {
      int e;
      /* ¢$ℓ₁$¢ */ if ((e=main(argc, argv,++envp)) !=0)
        return e;
    } while (*envp);
  }
  return i;
}
\end{CPP}
אף מבלי להכיר את שפת~\CPL על בוריה, ומבלי צורך לדעת את משמעותם של הפרמטרים
\E|argc|, \E|argv|, ו-\E|envp| לפונקציה \E|main|, ובוודאי מבלי צורך לפענח מה
עושה תכנית מוזרה זו (שאינה כוללת שימוש בספרייה הסטנדרטית של שפת~\CPL), ניתן
לזהות את הסביבה: בנקודה המסומנת~$ℓ₁$ בתכנית המתכנת יכול להשתמש בשישה שמות:
\mini{main}, \mini{argc}, \mini{argv}, \mini{envp}, \mini{i}, ו-\mini{e}, ולכל
אחד מאלו, ישנה משמעות משלו. הסביבה היא זו אשר מעניקה משמעות לשמות.
נשים לב לכך שהסביבה אינה זהה בכל התכנית. במיקום המסומן~$ℓ₀$ אין משמעות
לשמות \mini{i} ו-\mini{e}.

המונחים סביבה וטבלת סמלים הם מונחים דומים המציינים דברים דומים. המונח סביבה
משמש כדי להסביר ולהבין את שפת התכנות. המונח טבלת סמלים משמש כדי לתאר את האופן שבו
סביבה ממומשת בשפת תכנות.

§§ חזון השפה

§§ רקורסיה בהגדרות 

בשפת \פסקל הביטוי
\begin{PASCAL}
(-12+sin(13.4)) * x
\end{PASCAL}
הוא ביטוי מורכב המכיל בתוכו שלושה ביטויים אטומיים \קד{12}, \קד{13.4}
ו-\קד{x}. בביטוי מופיע הבנאי הבינארי של החיבור, הבנאי הבינארי של הכפל,
ושלושה בנאים אונאריים: סימן המינוס החד מקומי (\קד{-$·$}), הפונקציה החד מקומית
\קד{sin($·$)}, וגם בנאי אונארי נוסף המאפשר לעטוף ביטוי בסוגרים. על פי בנאי
זה, אם~$E$ הוא ביטוי אזי גם \קד{($E$)} הוא ביטוי, ועל כן, כיוון
ש-\קד{-12+sin(13.4)} הוא ביטוי אזי גם \קד{(-12+sin(13.4))} הוא ביטוי.

כל הגדרה רקורסיבית של קבוצת הביטויים המותרים לשימוש בשפת תכנות מסויימת, כוללת
קביעה מי הם הביטויים האטומיים, כלומר ביטויים שאינם מכילים בתוכם ביטויים אחרים.
בדרך כלל ביטויים האטומיים הם משני סוגים: ליטרלים כגון המספר השלם \קד{21} והמספר
הממשי \קד{13.4} ושמות, כגון \קד{x}. השיערוך של ביטוי מוגדר רקורסיבית. השיערוך
של ליטרל, הוא ערכו של הליטרל, ואילו שיערוך של שם נעשה באמצעות חיפוש השמות של
הערך המתאים לשם.

מלבד הביטויים האטומיים, ההגדרה הרקורסיבית של קבוצת הביטויים המותרים לשימוש,
כוללת בתוכה גם רשימה של בנאי ביטויים. בנאי ביטויים אונארי המופיע כמעט בכל שפת
תכנות נפוץ הוא זוג סוגריים: אם~$E$ הוא ביטוי, אזי 
גם~$⌘(E⌘)$ הוא ביטוי.

גם אופרטורים הם בנאי ביטויים נפוצים: אופרטורים אונאריים, כגון סימן המינוס החד
מקומי (\קד-) הם בנאי ביטויים אונאריים, שכן, אם~$E$ הוא ביטוי, אזי גם~$⌘-E$ הוא
ביטוי. אופרטורים בינאריים, כגון החיבור (קד+) והכפל (\קד*) הם בנאי ביטויים
בינאריים, שכן אם~$E₁$ ו-$E₂$ הם ביטויים אזי גם~$E₁⌘+E₂$ ו~$E₁⌘*E₂$ הוא ביטוי.
בשפת התכנות~\E|C|, כמו גם שפות תכנות אחרות, יש גם אופטור טרנרי, על פיו
אם~$E₁$,~$E₂$ ו-$E₃$ הם ביטויים אזי גם $E₁⌘?E₂⌘:E₃$ הוא ביטוי.

בנאי הביטויים כוללים בתוכם גם פונקציות. אם~$⌘f$ היא פונקציה~$n$-מקומית עבור
ו-$E₁,E₂,…,Eₙ$ הם ביטויים אזי גם \[
  ⌘f⌘)E₁⌘,E₂⌘,…⌘,Eₙ⌘)
\] הוא ביטוי. מקרה מעניין הוא זה שבו~$n=0$. פונקציה 0-מקומית יוצרת היא בנאי
\E|nullary|, שיוצרת ביטוי אטומי ללא שימוש בביטויים אחרים. בשפת~\E|\CPL|,
הכתיב~$⌘{f()}$ המשמש לקריאה לפונקציה ללא ארגומנטים, מטעים שפונקציה זו מהווה
בנאי \E|nullary|. בשפת פסקל, הכתיב~$⌘f$ המשמש לקריאה לפונקציה כזו מטעים
שפונקציה זו היא ביטוי אטומי.

האבחנה שגם אופרטורים וגם פונקציות הם בנאי ביטויים, מאפשרת לנו לזהות שהההבדל
ביניהם הוא דקדוקי בלבד ונוגע לאופן בו הם נכתבים, הבדל טכני ולא עקרוני:

\החל{אבגוד}
✦ אופרטורים נכתבים בדרך כלל בכתיב של \E|infix|, כלומר, בין הארגומנטים שלהם.
אופרטורים אונאריים יכולים להיכתב בכתיב של \E|prefix|, כלומר לפני הארגומנט שלהם,
או בכתיב של \E|postfix|, כלומר אחרי הארגומנט שלהם. לעומת זאת, פונציות נכתבות
תמיד בכתיב של \E|prefix|.
הביטוי הבא בשפת C מדגים אופרטרים הכתובים ב-\E|prefix|, \E|postfix|, ו-\E|infix|,
ופונקציות בנות 0, 1, ו-3 ארגומנטים הכתובות כולן ב-\E|postfix|.
\begin{CPP}
  g(a) ? f(++a,b++,h()) : a+b
\end{CPP}
✦ פונקציות המקבלות ארגומנט אחד או יותר נכתבות תמיד עם סימני סוגריים, ולכן, יש
רק דרך אחת לפרש ביטוי שבו הבנאים היחידים הם פונקציות.

לעומת זאת, אורפטורים נכתבים בדרך כלל ללא סוגריים. סדר הקדימויות של האופרטורים
הוא זה הקובע את מבנה הביטוי. הכתיב של אופרטורים קצר יותר, אך גם מחייב
שימוש בסימני סוגריים כדי להתגבר על סדר הקדימויות.

✦ השמות של פונקציות נראים בדרך כלל כמו "שמות רגילים", הכוללים בתוכם אותיות
אנגליות, ולעיתים גם ספרות, וסימנים מפרידים. לעומת זאת, שמות האופרטרים הם הרבה 
פעמים סדרה של סימני פיסוק. שמות רגילים לאופרטורים גם הם מופיעים:
למשל, שמו של האופרטור~$∧$ בשפת פסקל הוא המילה השמורה~$⌘{and}$.

מצד שני, קיימות שפות תכנות בהן ניתן לתת לפונקציות שמות המורכבים מסימני פיסוק
בלבד.

✦ אופרטורים בדרך כלל מוגדרים על ידי שפת התכנות, בעוד שפונקציות מוגדרות על ידי
המתכנת. יחד עם זאת, ישנן שפות תכנות רבות המאפשרות למתכנת להגדיר אופרטורים
חדשים שאינם מוכרים על ידי השפה. ומנגד, ישנן שפות תכנות שבהן ישנן פונקציות
המוגדרות על ידי השפה, ולא על ידי המשתמש.
\סוף{אבגוד}

§§ הגדרת רקורסיבית של פקודות בשפות תכנות
לבד מביטויים, תכניות גם מכילות פקודות אשר ביצוען מביא לשינוי של מצב התכנית. גם
גם קבוצת הפקודות מוגדרת בדרך כלל רקורסיבית, והגדרה זו כוללת בתוכה
הגדרה של בנאי פקודות ופקודות אטומיות.

פקודה אטומית יכולה להכיל בתוכו ביטוי, והביטוי יכול שיהיה ביטוי מורכב, גם אם
הפקודה עצמה היא אטומית.
לדוגמה, בשפת פסקל, פקודות אטומיות מכילות גם את פקודת ההצבה. כך,
\begin{PASCAL}
x:=(-12+sin(13.4))*x
\end{PASCAL}
היא פקודה אטומית שבה מחושב ערכו של הביטוי \קד{(-12+sin(13.4))*x},
ולאחר החישוב, הערך מוצב אל תוך המשתנה \קד{x}.
בפקודה זו נוכל לזהות תתי מרכיבים: למשל תת-הביטוי \קד{sin(13.4)}.
בכל זאת, הפקודה היא פקודה אטומית, שכן לא ניתן לזהות בה תת-מרכיב שהוא \פקודה
בעצמו. באופן כללי יותר, איבר מקבוצה המוגדרת רקורסיבית הוא איבר אטומי אם
לא ניתן לזהות בתוכו תת-איבר אחד או יותר השייך לאותה קבוצה. אבל איבר אטומי אינו
בהכרח לא פריק: האטומיות נובעת מכך שלא כל שנדרש הוא שלא ניתן לזהות בתוכה תת-איבר
מאותה קבוצה.

לבד מהצבה, בשפת התכנות פסקל ישנן פקודות אטומיות משלושה סוגים נוספים:
\begin{enumerate}
  ✦ \ע|קריאה לפרוצדורה|. זוהי פקודה כגון
  \begin{PASCAL}
WriteLn('Hello, World')
\end{PASCAL}
  אשר קוראת לפרוצדורה המוגדרת בשפה, או פרוצדורה המוגדרת על ידי המתכנת, כמו
  \begin{PASCAL}
ComputeSolution(1,5,6,x)
\end{PASCAL}
  ✦ \ע|פקודת קפיצה|. זוהי פקודה כגון
  \begin{PASCAL}
goto 999
\end{PASCAL}
  אשר בה בקרת הזרימה מועברת למקום אחר בתכנית. בדוגמה שלנו, הפקודה המסומנת בתגית
  999.
  ✦ \ע|הפקודה הריקה|. זוהי פקודה שאינה עושה דבר. אין צורך לכתוב דבר כדי
  להשתמש בפקודה זו, והיא משמשת בעיקר לצורך בניית פקודות מורכבות
\end{enumerate}
בשפת פסקל יש גם בנאי פקודות. החשובים ביותר הם אלו:
\begin{enumerate}
  ✦ \ע|בנאי הבלוק|. סדרה של פקודות המופרדות על ידי סימן הנקודה ופסיק~(\T|;|)
  והעטופה במילים \מש{begin} ו\מש{end} גם היא פקודה. בנאי הבלוק הוא בנאי רב
  מקומי, שיכול לקבל מספר כלשהו של פקודות, מורכבות או אטומיות, ולבנות מהם פקודה
  אחת. זו לדוגמה פקודה מורכבת הנוצרת על ידי בנאי הבלוק משתי פקודות אטומיות.
  \begin{PASCAL}
begin
  a:=b;
  goto 999
end
\end{PASCAL}
  נשים לב לכך שסימן הנקודה ופסיק (\קד{;}) מפריד בין פקודות ואינו חלק מהפקודה.
  לכן,
  \begin{PASCAL}
begin
  a:=b;
  goto 999;
end
\end{PASCAL}
  היא פקודה מורכבת הנוצרת משלוש פקודות אטומיות, שהאחרונה בהן ריקה. בנאי הבלוק הוא
  גם \E|nullary|, וגם
  \begin{PASCAL}
begin
end
\end{PASCAL}
  היא פקודה.
  ✦ \ע|בנאי לולאת ה-\קד{while}|. בנאי לולאת ה-\קד{while} הוא בנאי אונארי:
  אם~$C$ היא פקודה ו-$E$ הוא ביטוי בוליאני, אזי גם לולאת ה\קד{while}
  \begin{PASCAL}
while ⌘$E$⌘ do ⌘$C$⌘
\end{PASCAL}
  היא פקודה. על פי בנאי זה,
  \begin{PASCAL}
while x > sin(x) do x :=sin(x)
\end{PASCAL}
  ✦ \ע|בנאי התנאי החלקי|. גם בנאי התנאי החלקי הוא בנאי אונארי. לפי בנאי זה,
  אם~$C$ היא פקודה ו-$E$ הוא ביטוי בוליאני, אזי גם פקודת התנאי החלקי היא פקודה:
  \begin{PASCAL}
if ⌘$E$⌘ then ⌘$C$⌘
\end{PASCAL}
  ✦ \ע|בנאי התנאי המלא|. אם~$C₁$ ו-$C₂$ הן פקודות ו-$E$ הוא ביטוי בוליאני, אזי
  גם פקודת התנאי המלא היא פקודה:
  \begin{PASCAL}
if ⌘$E$⌘ then ⌘$C₁$⌘ else ⌘$C₂$⌘
\end{PASCAL}
  היא פקודה.
\end{enumerate}

קבוצת הפקודות במרבית שפות התכנות היא קבוצה המוגדרת רקורסיבית, ובתוך קבוצה זו,
אנו יכולים לזהות את הפקודות האטומיות. לעומת זאת, הפקודה הבאה
בפסקל,
\החל{PASCAL}
begin
c :=a;
a :=b;
b :=c;
end
\end{PASCAL}
אינה פקודה אטומית, שכן ניתן לאתר בה מרכיב שהוא \פקודה בעצמו.

\begin{editing}
§§ הגדרה רקורסיבית של טיפוסים בשפת תכנות
במרבית שפות התכנות, קבוצת הטיפוסים בהם ניתן להשתמש בשפה, גם היא מוגדרת
רקורסיבית. לדוגמה, מערכת הטיפוסים בשפת התכנות \E|Nִִִim|, ניתן לתיאור רקורסיבי
פשוט:
\begin{description}
  ✦ [טיפוסים אטומיים] אלו הם טיפוסים שאינם מורכבים משום טיפוס אחר. אחדים
  מטיפוסים אלו הם טיפוסים מוגדרים מראש בשפת \E|Nim|.
  \begin{description}
    ✦ {טיפוסי מספר שלם:}
    אלו כוללים את הטיפוסים
    \E|int|, \E|int8|, \E|int16|, \E|int32|, ו-\E|int64|,
    כמו גם את הגירסאות חסרות הסימן של טיפוסים אלו:
    \E|uint|, \E|uint8|, \E|uint16|, \E|uint32|, ו-\E|uint64|.
    ✦ {טיפוסי מספר ממשי:} הכוללים בתוכם את הטיפוסים float, float32, ו-float64.
    ✦ {הטיפוס char :} הכוללים בתוכם את הטיפוסים float, float32, ו-float64.
    :
    והם מכילים בתוכם את הטיפוסים הבאים:
  \end{description}
  ✦ [בנאי טיפוסים] אלו הם טיפוסים שאינם מורכבים משום טיפוס אחר.
\end{description}

קבוצת ה\טיפוסים של שפת \סי (כמו גם קבוצת הטיפוסים של שפת פסקל) אף היא קבוצה
המוגדרת רקורסיבית: ישנם טיפוסים מורכבים, אשר ניתן לזהות כי הם מורכבים מיחידות
קטנות יותר, אשר אף הן טיפוסים. בטיפוס רשומה למשל ניתן לזהות כיחידות קטנות יותר
את טיפוסי השדות הבונים את הרשומה. אנו אומרים שהטיפוס של רשומה הוא טיפוס
מורכב, משום שיש בו תתי-יחידות אשר אף הן טיפוסים.

לעומת הטיפוסים המורכבים, ישנם טיפוסים אטומיים, כלומר טיפוסים אשר לא ניתן לזהות
בתוכם טיפוסים אחרים. הטיפוס של מספרים שלמים או הטיפוס של מספרים ממשיים, הם
דוגמאות לטיפוסים כאלו.

המילה השמורה \מש{int} בשפת \סי \מזהה את הטיפוס האטומי של מספר שלם. מילים
שמורות המשמשות כ\מזהים נקראות מזהה שמור.

\end{editing}
ניתן להשתמש בשיטת ההגדרה הרקורסיבית, כדי להגדיר את קבוצת הפקודות בפסקל,

\begin{enumerate}
  ✦ \ע|פקודות אטומיות| פקודות אטומיות הן פקודות שאינן בנויות מפקודות אחרות. בשפת
  \סי יש שני סוגים של פקודות אטומיות,
  \begin{enumerate}
    ✦ \ע|פקודה ריקה| פקודה שאינה מבצעת דבר, נקראת הפקודה הריקה. הפקודה הריקה נכתבת
    בשפת אמצעות סימן הנקודה ופסיק~\cc{;}.
    ✦ \ע|פקודת ביטוי| בשפת \סי, כל ביטוי שאחריו מופיע סימן הנקודה ופסיק~\cc{;|}
    \begin{CPP}
      a; f(); b=2; 2;++i; 1-1;
    \end{CPP}
  \end{enumerate}
  קריאה לפרוצדורה
  כללי היצירה העיקריים של הפקודות הם:
  שרשור של פקודות המופרדות על ידי סימן הנקודה ופסיק (;) הוא פקודה.
  פקודת תנאי, כפי שתוארה לעיל, היא פקודה, אשר מכילה בתוכה פקודה אחת או שתיים.
  פקודת תנאי רבת ראשים המוגדרת באמצעות המילה השמורה case
  לולאות המתארות ביצוע איטרטיבי של פקודה (אטומית או מורכבת), אף הן פקודות. יש
  ב-Pascal שלושה סוגים של פקודות לולאה מורכבות: for
  while
  repeat until
\end{enumerate}

string, char, ו-bool,
וכו', וישנם בנאי טיפוסים המאפשרים להגדיר טיפוסים מורכבים מתוך טיפוסים
סוף{ציינון}

מערכים בשפת Pascal הם טיפוסים מורכבים: בנאי המערך קיבל כפרמטר את טיפוס של תא
במערך, והחזיר בתמורה את טיפוס המערך של תאים מאותו טיפוס.†{למען השלמות יש לציין
שבנאי המערך מקבל עוד שני פרמטרים, שהם קצוות המערך. ואפשר להפליג ולצין שבנאי של
מערך רב מימדי מקבל מספר זוגות של פרמטרים כנ"ל.}
איבר אטומי הוא איבר שנוצר מבנאי שלא קיבל כפרמטרים ערכים של הקבוצה.

ניתן להסתכל על הטיפוסים האטומיים מכוח עצמם: Character, Integer, Real, Boolean
כעל בנאים שאינם מקבלים פרמטרים כלל. טיפוסים מנויים (enumerated types) בִּשְׂפַת
פסקל, הם גם טיפוסים אטומיים (איברים אטומיים של קבוצת הטיפוסים) . הם נוצרו מבנאי
שמקבלל רשימה של תגיות. תגית היא מזהה חוקי בשפת פסקל.

§§ אבחנות חשובות
\ספרר
\item בין שם לבין משוים 
\item בין משתנה לבין ערך 
\item בין פקודה לבין ביטוי 
\item בין חישוב סידרתי ובין חישוב קולטרלי
\item  בין הגדרה, הכרזה ואיתחול
\item  בין הגדרה סידרתית ובין הגדרה קולטרלית 
===

§§ סיווג האסימונים 

§§אבחנה בין תיבה עליונה ותחתונה
למה קוראים להם תיבות עליונות ותחתונות? בעבר, בדפוס היתה תיבה גבוהה עם האותיות
הגדולות ותיבה נמוכה, תחתונה שבה האותיות הקטנות.

איך לומדים מהר שפה?
§§אוסף מילות מפתח

במרבית המקרים קל לנחש את המשמעות של רובם.

§§אוסף האופרטורים

גם כאן קל לנחש את המשמעות של רובם.
מיון אופרטורים: אונריים, בינריים, טרנריים.
מילולונים הם בעצם אופרטורים אפס מקומיים.

תופעות יחודיות

\ציינן
• סימן מיוחד למינוס אונרי…
• מגוון סימונים לאופרטור השונה מ
• הצבה? לא תמיד אופרטור.
===

§§אוסף המילולונים
בדרך כלל קל הרבה יותר. המילולונים הם די סטנדרטיים.
מספר שלם, או מספר ממישי, תוים וסדריות.
עיין לעיל מילולוני סדריות
§§גודל השפה
האם הקלט פלט הוא חלק מהשפה או שמא הוא חלק מהסיפריה הסטנדרטית.

הנטיה היום: שפה קטנה וספריה גדולה.

§§ חזון השפה
§§ חזון השפה

האם מתכנן השפה ניסה להגדיר דקדוק כזה המזכיר את השפה האנגלית.

§מאפיינים תכנוניים שניוניים
§§תכנית ריקה
האם השפה מקבלת תכנית ריקה?
§§גודל התכנית הקצרה ביותר
תכנית שאינה ריקה, אבל קצרה ביותר.
§§גודל ה\מהדר העצמי
נקודת שבת מענינת.
§§אורתוגונליות של התכנון
קשה בדרך כלל להבחין.

§§שיטת הביצוע
שפה ביצועית, לעומת שפה הצהרתית, שבה יש מנוע הקובע את שיטת החישוב.
\ציינן
• הדור לשפת מכונה
• הדור לשפה אחרת.
• פרשנות
• תרגום למכונה אבסטרקטית.
===
יש גם מכונה אבסטרקטית הצהרתית לשפת \פרולוג.§ מקום תחילת ביצוע

נעסוק בתת-פרק זה בסוגיית \מונח[מקום תחילת ביצוע התכנית]{מקום תחילת התכנית}
ביצוע התכנית.

ראינו, בין השאר בתכניות "שלום, עולם!", הוראות בקוד אשר אחראיות להדפסת שורות
טקסט. חלק מהוראות מעין אלו מכונות "\פקודות", והן בין השאר מרכיבות תכנית.
\פקודות עשויות להיות מאוגדות במקטעים, שכל אחד מהם מכוה \מונח{בלוק}. בלוקים אלו
עשויים להיות \מונח[קינון]{מקוננים} אלו באלו, וניתן לכנותם בשם. בשפות שונות,
ובכללן שפת \סי, לבלוקים משוימים כאלו ניתן השם "פונקציה" (בְּ-\שי{Pascal}, למשל,
מבחינים בין "פונקציות" ל"פרוצדורות" - שני סוגים שונים של בלוקים שכאלו).

בהינתן אחת מאותן פונקציות, כפי שתוארו, ניתן ללמוד רבות אודות הפונקציות לה תקרא
הפונקציה שבידינו. ניתן גם ללמוד, בתלות מסוימת בכישורינו אנו ובכישוריו של הוגה
הפוקנציה, מה תכליתה וכיצד היא מגשימה תכליתה זו. דא עקא, לא ניתן ללמוד מקריאה
כזו או אחרת מי יקרא לפוקנציה. הדבר שקול לקריאת ספר בישול. מעיון בספר, עמוק ככל
שיהיה, לא יוכל לדעת איש מי יקרא בספר ואילו פשעים קולינריים יחולל בשמו.

נרצה לקוות שבשפות תכנות בהן נשתמש יוגדר סדר ביצוע בין הבלוקים האלו
\הערת␣שוליים{דטרמיניזם ועקביות בשפות תכנות הינה דבר כמעט הכרחי במערכות גדולות.
עם זאת, יש לכך חריגות. לפרטים נוספים.}. במילים אחרות, שפות שונות מגדירות בצורה
שונה את \מונח{מקום תחילת ביצוע התכנית} של תכנית מחשב, בפרט כאשר התכנית מורכבת
מקבצי טקסט שונים המכילים, בין השאר, בלוקים מהסוג שתואר.

נתאר לפיכך גישות שונות של שפות תכנות שונות באשר לסוגיה זו.
\begin{enumerate}
•\גיבור{הגישה האוטרקית - פסקל:} על פי \מונח{הגישה האוטרקית}, קיימת בתכנית מילה
מוגדרת מראש, שחייבת להופיע פעם אחת ויחידה בתכנית, אשר החל ממנה מתחילה לרוץ
התכנית. בשפת \שי{פסקל}, למשל, המילה השמורה \קד{program} מגדירה את מקום תחילת
ביצוע התכנית. בשפת התכנות \שי{AWK}\הערת␣שוליים{שפת סקריפט שפותחה במעבדות בל
בשנת 1977. תוכננה לעיבוד טקסט וזהו עיקר השימוש בה.} התכנית מתחילה לרוץ החל
מהמילה השמורה \קד{begin}, אך בשפה זו אין חובה לתת שם לבלוק ממנו מתחיל הביצוע.

• \גיבור{הגישה המטאפיזית - שפת \סי:} \מונח{הגישה המטאפיזית} היא הנפוצה יותר
בשפות תכנות, לפיה ריצת התכנית מתחילה בפונקציה בעלת שם מסוים, אלא ששם זה אינו
מוגדר מראש, אלא ניתן לשינוי ע"י המשתמש. שם הפונקציה ממנה מתחילים בפרט אינו
מוגדר על פי סביבת העבודה. בשפת \סי, למשל, ממומשת גישה זו, ולא קיימת מילה
המקבילה ל-\קד{program} בְּPascal. ריצת התכנית מתחילה בדר"כ-מהפונקציה \קד{main},
ועם זאת אפשר לשנות זאת באמצעות הגדרות ההידור של תכנית. להלן דוגמה לכך משפת \סי:
(המקור- מסמך "צעדים ראשונים", עמוד 20)

\lstinputlisting{Sources/hello.cpp}

• \גיבור{הגישה ההוליסטית - \גאוה:} גישה שמכלילה את הגישה הקודמת. לפי גישה זו,
נקודת התחלת הביצוע עודנה חיצונית לשפה עצמה, אך עם זאת השפה מגדירה קביעות
מדויקות באשר לנקודת תחילת הביצוע. לא יתכן במצב זה כי תחילת הביצוע תוגדר
ב\מונח{סביבת הפיתוח}, ולכן לא יתכן שתהיה נקודת תחילת ביצוע שונה ב-2 סביבות
פיתוח שונות. הנ"ל-מתקיים בשפת \שי{Eiffel}, שם כותב המתכנת קובץ בתחביר הדומה לזה
של השפה, בו מוגדרת בין היתר נקודת תחילת הביצוע. זהו המצב גם בשפת
\גאוה\הערת␣שוליים{ברוסית - קרפדה!}, בה ניתן באמצעות מנגנון בשם "\מונח{צורת
התבוננות}", להתחיל ביצוע מכל מקום, בעזרת פונקציית \קד{main} בכל מחלקה.
הנ"ל-מציב קושי בתכנון שפה יבילה והוליסטית (מדוע?).

• \גיבור{הגישה של ביצוע אינטרקטיבי - שפות עם מפרשים:} בשפות מֵפוׂרַשוׂת, המצב מעט
שונה. תחילת ביצוע התכנית היא בפקודה הראשונה המובאת בפני ה\מונח{מפרש}, וממשיכה
הלאה ככל שחפץ לב המתכנת להמשיך ולתת פקודות בפני מפרשו. הנ"ל-מתרחש בלולאה
המכונה: \קד{read-interpret-execute-loop (reipl)}. משמעותה נובעת משמה - עבור כל
פקודה מבצע המפרש ארבעה שלבים בעיבוד הפקודה: קריאתה, פרשונה, ביצועה והמשך לפקודה
הבאה. נקודת ההתחלה תהיה אפוא הפקודה הראשונה המוקלדת, או הנטענת לפרשון. שפה
המממשת עקרון זה היא \שי{Ocaml}.

\end{enumerate}

עסקנו עד כה בנקודת תחילת הביצוע של תכניות מחשב, ועם זאת זנחנו את הנושא החשוב
מכל: איך המחשב מתחיל לעבוד? הרי ידוע לכל שעל מנת להפעיל תכניות מחשב, על תכניות
אחרות להפעילן טרם לכך. נשאלת השאלה מי הפעיל את התכנית הראשונה? ובכן, נסביר:
בחומרת המחשב קיים קוד צרוב, כלומר סדרת הוראות בסיסיות למחשב הצרובה
ב\מונח{זיכרון קריאה בלבד} - מדובר בקובץ הוראות בסיסי ביותר הגורם לביצוען של
הפעולות ההִיוּלִיוֹת ביותר בהפעלת המחשב. הן מפעילות אחת, בשלב מסוים קוראות מידע
והוראות מזיכרון המחשב, ובעקבותן מופעלת אחרת, בשרשרת עד להדלקת המחשב. למותר
לציין שהתהליך כולל שלבים מרובים, בהם ניתן לעשות בדרגות שונות. למעוניינים
בהרחבה: הסבר קצר, הסבר מקיף יותר, פקולטה שזהו עניינה.

§ רקורסיה הדדית
נתאר לעצמנו שתי פונקציות הקוראות זו לזו ברקורסיה הדדית, \קד{f()} ו-\קד{g()}.
נתאר לעצמנו שני טיפוסים \שי{Male} ו-\שי{Female} שהגדרת האחד תלויה בהגדרת האחר.
איך ניתן לכתוב זוג הגדרות שתלויות זו בזו הדדית? במיוחד בשיטה שבה ה-\מונח{טווח}
מתחיל בהגדרה, ומסתיים בסוף הבלוק?
שתי אפשרויות עיקריות:
\begin{enumerate}
• ניתן להשתמש בשם של טיפוס עוד לפני שהטיפוס הוגדר.
\ציינן
• בִּשְׂפַת \סי, אפשר להגדיר משתנה המצביע לטיפוס רשומה, עוד לפני שהטיפוס מוגדר.

\lstinputlisting[language=C]{Sources/pointer-before-declaretion.c}

 בדוגמה רואים הגדרה של המשתנה \קד{p} שהטיפוס שלו הוא מצביע למשתנה מהטיפוס \קד{struct Data} וזאת עוד לפני שהטיפוס \קד{struct Data} הוגדר.
• בשפת \פסקל, ניתן להשתמש בטיפוס של מצביע לטיפוס, עוד טרם שהטיפוס הוגדר.
===
• ביצוע Declaration לאחד מבני הזוג, ואחר כך, Definition לבן הזוג השני, ולבסוף Definition לבן הזוג השני.
\ציינן
• הנה דוגמא בִּשְׂפַת \סי:

\lstinputlisting[language=C++]{Sources/declaration-and-definition.c}{C}

• והנה דוגמא בִּשְׂפַת \פסקל:

\lstinputlisting[language=C++]{Sources/declaration-and-definition.pas}{Pascal}

===
\end{enumerate}

§§ רקורסיה הדדית הבנויה בשפה
כאשר תוכננו שפות התכנות הראשונות, למחשבים היה כוח חישוב מועט. ההידור התבצע ככל
שאפשר במעבר אחד על התכנית. זו אחת הסיבות לקיום כלל ה-Scope לפיו הגדרה מוכרת
מהשורה שבה היא מבוצעת ועד לסוף הבלוק. בשפות תכנות חדשות יותר, כמו \גאוה, שְׂפַת
\שי{C++}, וְ-\שי{C＃}, קיים מנגנון חזק יותר, לפיו הטווח של הגדרה הוא הבלוק שבה
היא מתבצעת, כלומר ה-Scope של הגדרה יכול להתחיל עוד לפני שההגדרה עצמה בוצעה.

\lstinputlisting[language=C++]{Sources/friendly-rec.cpp}{C++}

§§ הגדרות קולטרליות
הגדרות של פונקציות ומחלקות בתוך מחלקה של \שי{C++}, או \גאוה, מוכרות בכל המחלקה.
תכונה זו מאפשרת רקורסיה הדדית. המצב ההפוך מתקיים בהגדרות קולטרליות. המילה
קולטרלי באה לומר שאין לאף הגדרה עדיפות לאחרת, כל אחת מהן יכולה להופיע לפני כל
אחת אחרת. הצורך בהגדרות קולטרליות (או סימולטניות) אינו ברור מיידית, וזו אולי
הסיבה שהן נדירות, אבל הן קיימות בִּשְׂפַת \שי{ML}, באמצעות המילה השמורה \מש{and}.

הנה דוגמא לשימוש במילה זו
\begin{center}
\קד{val x=y and y=x}
\end{center}

בהגדרה זו, המשמעויות של המזהים x וְ-y מתהפכות.

§ הסכנה שבתכניות המשעשעות המדפיסות את עצמן

מהי תכנית המדפיסה את עצמה? ובכן, הגדרה נאיבית תהיה תכנית אשר הפלט שלה היא היא
עצמה, אך נחדד, שהרי גם התכנית הריקה תענה על הגדרה זו, ולא נרצה פתרון פשטני כל
כך שייחשב פתרון תקף לבעיה אלגנטית זו. לא נרצה גם שתכנית שמקבלת את עצמה כקלט
טקסטואלי ומדפיסה טקסט זה תיחשב, שכן מדובר בפתרון טכני בלבד.

לפיכך, ההגדרה היא כדלקמן: תכנית המדפיסה את עצמה, \מונח{דפסן}, היא תכנית לא ריקה
אשר לא מקבלת קלט והפלט היחידי שלה הוא התכנית עצמה (כך נימנע גם מלכלול תכניות
אשר מדפיסות לאורך הזמן את כל הפלטים האפשריים, בזה אחר זה, עד אשר תדפיס בעת
מסוים את עצמה). תכניות מעין אלו מהוות אבן שואבת במדעי המחשב, וניתן להתייחס
אליהן בצורה מתמטית באופן הבא: אם נתייחס לסביבת הביצוע כאל פונקציה (מקבוצת
התכניות אל קבוצת הפלטים), נקבל כי תכנית המדפיסה את עצמה היא נקודת
שבת\הערת␣שוליים{\שי{Fixed Point}. נציין כי למונח הרחבות רבות בתחום הטופולוגיה
המתמטית, המכלילות את המונח למרחבים מטריים שונים. לפרטים נוספים.}.

בנוסף, מבחינה ספרותית, ניתן לומר שקוד שכזה הוא קוד ארס-פואטי, שכן הוא עוסק
בכתיבת קוד בעצמו.

נראה מספר דוגמאות\הערת␣שוליים{ראוי להדגיש נקודה חשובה זו.} לתכניות המדפיסות את עצמן:

\lstinputlisting[language=Java]{Sources/quine.java}
\lstinputlisting[language=Perl]{Sources/quine.perl}
\lstinputlisting[language=Python]{Sources/quine.py}

ולהלן דוגמה ב-שיא חד, המלווה בהסבר ובהרחבה.

מהו הטריק\הערת␣שוליים{סיבה נוספת להתעניינות בנושא זה היא הופעתו כשאלה בשיעורי הבית, בסמסטר בו נכתב סיכום זה.} שבזכותו עובדות תכניות אלו? ניתן לחלק באופן גס את הקוד ל-2 חלקים:
\begin{enumerate}
• מערך מחרוזות ו/או אוסף קבועים, אשר מכילים את קוד הביצוע של התכנית.
• קוד הביצוע של התכנית, אשר מכיל הוראות להדפסה פעמיים של מערך המחרוזות המדובר, וכן קבועים נוספים הדרושים לשכפול מדויק של הקוד לתוך מה שיודפס.
\end{enumerate}
בריצת התכנית יודפס, כאמור, פעמיים המערך והתווים הרלוונטיים - בפעם הראשונה עבור הדפסת החלק הראשון של התכנית (מערך המחרוזות), ובפעם השנייה עבור הדפסת החלק השני - קוד הביצוע ממש.

עם זאת, טמונה בקודים מעין אלו סכנה של ממש. תכניות כאלו עשויות להוות כלי להחדרה של \מונח{וירוסים}\הערת␣שוליים{למעשה, מינוח מדויק יותר הוא סוס טרויאני, מונח שעל משמעותו ניתן וראוי לדון רבות.} בידי זֵדִים\הערת␣שוליים{הסבר מלא למילה זֵד שֵם ז: בלשון המקרא אדם רע, רשע; "טָפְלוּ עָלַי שֶׁקֶר זֵדִים" (תהלים קיט סט). [מילון רב-מילים]}. כתב על כך \מונח{קן תומפסון}\הערת␣שוליים{אבי !UNIX חלוץ אמריקאי בתחום מדעי המחשב, ידוע בשל תרומתו לפיתוח שפות התכנות B,Go והגדרת UTF-8} במאמרו\הערת␣שוליים {להבנה מלאה יותר של אופן הפעולה של סוס טרויאני, ניתן ללחוץ כאן.
 }.

נתחיל בתיאור מנגנון רלוונטי. נניח שנתון לנו קובץ המקור של המהדר של שפת \סי,
ונרצה להכניס בו שינוי מסוים - נרצה שבהינתן תו הבקרה \קד{/v}, תודפס מפלצת
\קד{ASCII} הזו. כיצד נעשה זאת? ובכן, בהינתן קוד המקור האידיאלי הבא של המהדר,
נגלה כי אין זו משימה קשה במיוחד:

מדובר בקוד המקבל תווים בשפה, ומחזיר את התו הרלוונטי עבור כל מקרה. היות שהמהדר
של שפת \סי כתוב בעצמו בשפת \סי, המהדר של השפה "מכיר" את התווים המיוחדות האלו,
ויודע "מה לעשות".

על מנת להשלים את הקוד על מנת שיכיל את התוספת שלנו (ידוע שהדפסת מפלצות
\קד{ASCII} שכאלו מביאה למורת רוח מרובה בקרב המשתמשים), נבצע את השינוי הבא:
הוספנו את השורה המתאימה, וננסה עתה להדר את הקובץ החדש של המהדר באמצעות המהדר
הישן שברשותנו. אך, אבוי, שוד ושבר, נקבל שגיאה! הרי המהדר הישן לא יודע מפלצות
\קד{ASCII} מהן, ולא יודע מהו התו \קד{/v}.

נרצה לפיכך "לאלף" את המהדר הישן להכיר תוסף זה, על מנת שיוכל להדר אותו, ולהפוך
אותו ל\מונח{מהדר} תקני המכיל את השינוי. ניגש אפוא לקובץ המקור של המהדר הישן,
ונוסיף בו את השינוי הבא (אחרון, מבטיחים!): כעת, המהדר הישן מכיר את התו \קד{/v}.
נניח שקיימת מחרוזת תווים כלשהי, המייצגת את מפלצת ה-\קד{ASCII} המועדפת עלינו,
וכי היא מיוצגת ע"י ה-11 בדוגמה שלהלן. נהדר באמצעותו את המהדר החדש שכתבנו, ונקבל
\מונח{קובץ} \קד{binary} שמכיל \מונח{מהדר} חדש, המטמיע את התוספת החדשה. ניתן
באמצעות תוצר זה להדר תכניות שיבצעו תוספת זו.

באופן דומה, אך זהה מבחינה רעיונית, ניתן, לאחר מאמץ מחשבתי ניכר, לתאר נזקים
כבירים אף יותר מהופעה של מפלצת (מאיימת ככל שתהיה) על צג המחשב. דוגמה לכך היא
פריצה לחשבונות פרטיים במערכות \שי{UNIX}, ע"י הוספת פרצה, לפיה ניתן יהיה להתחבר
לכל חשבון באמצעות סיסמא כלשהי (נניח \קד{iAmHackerHoHoHo}). בשלב הבא, נבצע את
התהליך כפי שביצענו בדוגמה הקודמת, ובאמצעותו נקבל את מערכת \שי{UNIX} החדשה, בה
תהיה קיימת פרצה זו. הפרצה תהיה מקודדת ומוטמעת במערכת החדשה, ללא יכולת זיהוי.
זהו \מונח{סוס טרויאני} עמיד בפני התקפות.

§ גבולות התכנית

נוסחת הירון לחישוב השטח S של משולש שגדלי צלעותיו הן a, b וְ C היא אלגנטית במיוחד: \[
S=√{p·(p-a)·(p-b)·(p-c)}
\] כאשר \[
p=\frac{a+b+c}{2}
\] הבה נכתוב בזריזות תכנית \פסקל בעבור הנוסחה הזו

\lstinputlisting[language=Pascal]{Sources/triangle.pas}
{לדוגמא תכונית}

מי שכתב אי פעם תכנית בִּשְׂפַת מכונה כלשהי, יכול לשוות בנפשו כיצד יתרגם המהדר את התכנית לעיל לשפת המכונה שעליה היא תרוץ, למעט ענין פעוט אחד: ידוע לכל כי ישנן פקודות מכונה לחישוב הסכום הסכום, המכפלה, ההפרש והמנה של שני מספרים ממשיים. אבל, כיצד יחושב השורש הריבועי? אפילו אם נניח כי יש המכונה מכילה פקודה לחישוב השורש, עדיין ישנה השאלה של התרגום של פקודות הקלט והפלט שבתכנית, שהרי אלו בוודאות אינן מצויות באוסף פקודות המכונה.
על כרחך אתה נאלץ לומר כי התרגום של תכנית בִּשְׂפַת תכנות מסוימת, פשוטה ככל שתהייה, לשפת מכונה, חייב להשתמש בפרודצרות ופונקציות אשר אינם מצויים בתכנית עצמה. השאלה בה עוסק פרק זה היא, בניסוח לא פורמלי, היא: "כיצד נקבעים גבולות התכנית?"\הערת␣שוליים{הקורא הכמה בשלב זה לארמז ספרותי או תיאולוגי, יכול לללמוד מעט על התהליכים היהודיים והננוצריים של קנוניזציה של כתבי הקודש, אשר בהם נקבע אלו מבין הספרים שייכים לתנ"ך. פלגים שונים בנצרות הגיעו לתוצאות שונות ביחס לשאלה זו. מעניין לציין כי בתנ"ך היהודי ישנם מה שהיינו קוראים שגיאות עקידה \שי{(Linking Error)}, ככתוב "כִּי אַרְנוֹן גְּבוּל מוֹאָב בֵּין מוֹאָב וּבֵין הָאֱמֹרִי. עַל-כֵּן יֵאָמַר בְּסֵפֶר מִלְחֲמֹת יְהוָה: אֶת וָהֵב בְּסוּפָה וְאֶת הַנְּחָלִים אַרְנוֹן…" אלא שספר מלחמות ה' אינו מצוי בידינו. (אגב, בברית החדשה הנוצרית, בכל הגדרותיה השונות, אין הפניה לספרים חיצוניים או לספרים שאבדו.)
}, או בלשון אחרת, בהינתן שְׂפַת תכנות מסוימת, ובהינתן כל קטעי הקוד הקיימים בעולם הכתובים בשפה זו:

\ציינן
• אלו קטעים יוצרים תכנית מסוימת, ואלו תכנית אחרת?
• האם יתכן שקטע קוד מסוים יהיה שייך ליותר מאשר תכנית אחת? ואם כן, מתי יקרה הדבר?
• היאך מוגדר בכלל "קטע קוד"?
• בהינתן כל קטעי הקוד מהם מורכבת התכנית, כיצד נקבע מאיזה מהם יתחיל הביצוע?
===

כדי לדעת את התשובה לכל אלו, בדרך כלל אין זה מספיק להכיר את הדקדוק והמשמעות של
השפה, אלא נדרשת הבנה של הסביבה בה פועלת התכנית, והאינטרקציה של התכנית עם
סביבתה.  הגישה הנקוטה בִּשְׂפַת פסקל, היא \גיבור{הגישה האוטרקית}, על פיה יש רק קטע
קוד אחד היוצר תכנית, וקטע זה מצוי בקובץ אחד. כל הפונקציות והפרוצדורות אשר
יכולות להיות מופעלות על ידי התכנית מצוייות בקטע זה, או מוגדרות על ידי שְׂפַת
התכנות.

בְּPascal ישנה גם מילה שמורה \מש{program} המגדירה את התחלת התכנית, באשר הביצוע יתחיל במילה השמורה \מש{begin} המתאימה לה. בשפות אוטרקיות אחרות, כמו גירסאות ישנות של בייסיק למשל, תחילת הביצוע יכולה להקבע בדרך אחרת, למשל מהפקודה הראושנה בתכנית.

הגישה האוטרקית בְּPascal נובעת מייעוד השפה ללומדים. לשם קיומו של חזון זה, בחר מתכנן השפה גם להימנע משימוש בספריות. כל הפונקציות והפרודצרות אשר בהן יכול המתכנת בשפה להשתמש הן אלו שהוא כתב בעצמו, או אלו שמוגדרות כחלק מהשפה. בפרט, המפרט של הפונקציות \מוגדרת␣מראש{writeln} וְ-\מוגדרת␣מראש{writeln} מצוי בהגדרת השפה עצמה. יוצר השפה בחר שלא להשתמש במילים שמורות בכדי לציין את הפונקציות והפרוצדרות המוגדרות על ידי השפה, אלא לקבוע שאלו הם מזהים מוגדרים מראש. הבחירה הזו מבטיחה ששירותים אלו יהיו זמינים למתכנת בכל עת, זאת, מבלי לסרבל את השפה בהגדרה של מספר גדול של מילים שמורות, אשר ימנעו מהמתכנת להשתמש במילים אלו לצרכיו.

רעיון זה מתפרס בְּPascal לא רק על הפונקציות והפרוצדרות, אלא גם על הטיפוסים
היסודיים, ואף על שמות הקבועים. המילים \קד{true}, \קד{integer} וְ-\קד{false} אינן
מילים שמורות בשפה, והמתכנת יכול להגדירן מחדש. בפרט, התכנית הבאה המדגימה את
סיסמת המפלגה בספר 1984 של ג'ורג' אורוול היא תכנית חוקית בְּPascal:

\lstinputlisting[language=C++]{Sources/1984.pas}{Pascal}{מספר? ... הוא ושקר שקר הוא אמת}

מרבית הסיכויים הם שאם תזין תכנית זו במהדר ה-Pascal החביב עליך, הוא יפלוט בתגובה
שגיאות הידור לרוב. התפתחות השפה הביאה לכך שהמילים \קד{true} וְ-\קד{false} הפכו
בחלוף השנים למילים שמורות, וההבדל בין המילה \קד{true} ובין הישות שהיא מציינת,
הלא היא ערך האמת המופשט, נמוג.

מנגד, האבחנה בין הסימון ובין הישות שהוא מייצג מתחזקת בשפות מודרניות, אשר בהן
הסימן '+' למשל, נבדל מפעולת החיבור אותה הוא מייצג. כך ב\שי{C++} למשל, המתכנת
יכול להשתמש בסימן זה גם לפעולות אחרות באמצעות תהליך הקרוי העמסת אופרטורים.

מנגד לגישה האוטרקית, קיימת \גיבור{הגישה המטאפיזית} הנקוטה על ידי שְׂפַת \סי. על פי
גישה זו, תיחום התכנית נעשה מבחוץ לה, באמצעות כלים אשר אינם מוגדרים בשפה. בגישה
זו, אוסף של קטעי קוד המצויים (למשל) בקבצים שונים נאסף על ידי
העוקד\הערת␣שוליים{הלא הוא ה-Linker} לכדי תכנית אחת, אך השפה עצמה אינה מתייחסת
להגדרת העוקד. העוקד גם מחבר לתכנית ספריה של שירותים. הספריה היא סטנדרטית, במובן
זה, שלהגדרת השפה נלווית גם הגדרה של הספריה הסטנדרטית, אך שתי הגדרות אלו הן בלתי
תלויות. ניתן לשנות ולפתח את הספריה הסטנדרטית מבלי לשנות את השפה ואת המהדר שלה.
המתכנת אף הוא יכול לבחור להחליף חלקים מהספריה הסטנדרטית, או את התכנית כולה.

§ שם לעומת ישות

כדאי לחדד את ההבדל בין שם ובין ישות. השם מציין את הישות והוא אינו זהה לה.
לעיתים יתכן שלאותה ישות יהיה יותר מאשר שם אחד, ויתכן גם כי לישות מסוימת יהיו
מספר שמות.  נעיין למשל בקושיה הבאה, אשר התשובה עליה עשויה לעורר קושי אצל יהודים
מאמינים שאין להגות את (מה שהם סבורים כי הוא) ה"תשובה הנכונה", ויתירה מכך,
כי יש להתייחס ביראת כבוד אל טכסטים אשר התשובה הנכונה כביכול מופיעה בהם:
מהו השם המפורש?

מתברר כי התשובה לשאלה זהו היא קלה ואינה מעוררת כל קושי, שכן השם המפורש אינו אלוהים, והוא אינו גם שמו של אלוהים. השם המפורש הוא שמו של שמו של אלוהים. ליתר דיוק, השם המפורש הוא שם קיבוצי לשלושה "שמות מפורשים" של אלוהים:
\ציינן
✦ Tetragrammaton, הטטראגאמאטון, הלא הוא השם המפורש בן ארבע אותיות.
✦ השם המפורש בן 42 אותיות.
✦ השם המפורש בן ה-216 אותיות המחולקות ל- 72 מילים שכל אחת מהן היא בת שלוש אותיות.†{ידיעת השם המפורש הארוך הזה, והגייתו היא זו אשר מאפשרת לגיבורו של "פרקי שיר השירים" (אשר פתיחתו הובאה לעיל), לרחף באוויר ולעשות עוד מעשי קסם וגבורה (כך על כל פנים הוא מתרברב בפני לילי אהובתו-אחייניתו).}
===

בשפות תכנות יש ישויות למכביר אשר אין להן שם. הנה כמה דוגמאות:
\ציינן
✦ משתנה אשר הוקצה באמצעות malloc בִּשְׂפַת C הוא משתנה אשר אין לו שם.
     ✦ שפת התכנות ML כמו גם הרחבות של שְׂפַת C++מאפשרת הגדרת פונקציות ללא שם.
      כך למשל, ההגדרה
      fn x=> x * x
      מציינת פונקציה אנונימית אשר מחזירה את הארגומנט שלה כשהוא מועלה בריבוע.
     ✦ בִּשְׂפַת C אין שם (למשל) לטיפוס מצביע למצביע למספר שלם, כמו גם לשורה ארוכה של טיפוסים אחרים.
     ✦ בִּשְׂפַת C ניתן להגדיר טיפוס של רשומה, מבלי לתת שם לטיפוס, למרות העובדה שהגדרת טיפוס רשומה מלווה בדרך כלל במתן שם לטיפוס.
      כך למשל, קטע הקוד הבא יוצר טיפוס חדש שהוא אנונימי, מגדיר משתנה מהטיפוס הזה אשר יש לו שם, ומאתחל משתנה זה.

    ===
\begin{verbatim}
struct {
  char *first;
  char *last
} boy={ "Danny", "Dean"};
\end{verbatim}

המצב בו לאותה ישות יש יותר מאשר שם אחד, אף הוא אפשרי בשפות תכנות. כדי לראות
דוגמא פשוטה לכך, נשווה רגע לנגד עינינו פרוצדורה בְּPascal המעבירה משתנה by
reference לפונקציה המוגדרת בתוכה. בתוך הפונקציה יהיו למשתנה הזה שני שמות:
הראשון הוא עקב העובדה שהפונקציה המוכלת מכירה את כל המשתנים של הפרוצדורה המכילה,
והשני, הוא שם הפרמטר המתאים. הנה תכנית המדגימה זאת:

\begin{verbatim}
program n;
var a: integer;
  function t(var b:integer): boolean;
  (* This function seems to always return true, right? *)
  begin
    a :=~1; b :=succ(a); t :=a<> b
  end;
begin
   writeln(t(a))
end.
\end{verbatim}

בדוגמא זו, הסתכלות על הפונקציה t לבדה, עלולה להביא אותנו לחשוב שהפונקציה תחזיר
תמיד את הערך true, שכן לא יתכן שמספר שלם יהיה שווה לעוקב לו. עיון מדוקדק יותר
יגלה את הטעות. הקריאה לפונקציה תיצור בה מצב שבו לאותו משתנה יש שני שמות, ועל
כן תוצאת הפונקציה תהיה false זה גם יהיה הפלט של התכנית כולה. מתן שם לשם אף
הוא אפשרי בשפות תכנות. כך למשל בִּשְׂפַת הסקריפטים bash ניתן לפרש סדרית נתונה כשם
של משתנה, לקרוא את תוכן המשתנה הזה, לפרשו גם כשם של משתנה אחר, וכן הלאה עד בלי
די.

